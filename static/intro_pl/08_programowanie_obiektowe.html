<!doctype html>
<meta charset="utf-8">
<title>Programowanie obiektowe</title>
<link rel=stylesheet href=doc.css>
<link rel=author href=http://marijnhaverbeke.nl/>
<link rel=license href=http://creativecommons.org/licenses/by/3.0/deed.pl>
<h1>Programowanie obiektowe</h1>

<div class="block">
  <p>Na początku lat 90. w branży programistycznej powstało zamieszanie spowodowane programowaniem obiektowym. Większość zasad tej techniki nie była żadną nowością, ale osiągnęła ona na tyle dużą popularność, że w końcu nabrała pędu i zaczęła robić się modna. Pisano książki na jej temat, przeprowadzano kursy oraz tworzono nowe obiektowe języki programowania. Nagle wszyscy zaczęli wychwalać pod niebiosa zalety obiektowości i z entuzjazmem używać jej do rozwiązywania wszystkich możliwych problemów. Wyglądało to tak, jakby niektórzy byli przekonani, że w końcu odkryli <em>prawidłowy sposób pisania programów</em>.</p>
  <p>Jest to dość typowe.. Gdy coś jest bardzo skomplikowane, ludzie zawsze szukają jakiegoś magicznego rozwiązania. I gdy pojawi się cos, co tak wygląda, od razu zyskuje potężną rzeszę oddanych wielbicieli. Do dziś dla wielu programistów obiektowość (albo ich wyobrażenie obiektowości) jest świętością. Dla nich program, który nie jest „prawdziwie obiektowy” (cokolwiek to znaczy), to słaby program. </p>
  <p>Niemniej jednak niewiele jest przejściowych mód, które przetrwałyby tak długo. Sukces obiektowości można w dużym stopniu tłumaczyć tym, że jest oparta na solidnych podstawach. W tym rozdziale znajduje się opis właśnie tych podwalin obiektowości oraz ich adaptacja w JavaScripcie. Chcę też podkreślić, że w poprzednich akapitach nie chciałem zdyskredytować obiektowości jako takiej. Moją intencją było tylko ostrzec Cię przed nadmiernym przywiązywaniem się do tej metodologii programowania.</p>
</div>
<hr>
<div class="block">
  <p>Jak nazwa wskazuje, <strong>programowanie obiektowe</strong> polega na używaniu obiektów. Do tej pory używaliśmy ich do luźnego grupowania wartości, dodając i usuwając z nich dane, gdy tak się nam podobało. W programowaniu obiektowym obiekty są traktowane jak małe samodzielne światy, a świat zewnętrzny może się z nimi kontaktować tylko poprzez niewielki ściśle zdefiniowany interfejs, będący zestawem metod i własności. Przykładem tego jest lista osiągniętych celów, której używaliśmy na końcu <a href="/kursy/javascript/wszystko-jasne/r7-wyszukiwanie">rozdziału 7</a>. Do posługiwania się nią używaliśmy tylko trzech funkcji: <code>makeReachedList</code>, <code>storeReached</code> oraz <code>findReached</code>. Te trzy funkcje stanowią interfejs tego typu obiektów.</p>
  <p>To samo dotyczy obiektów <code>Date</code>, <code>Error</code> i <code>BinaryHeap</code>. Zamiast zwykłych funkcji do pracy z obiektami, do dyspozycji mamy słowo kluczowe <code>new</code> do tworzenia obiektów, które wraz z pewną liczbą metod i własności stanowi ich interfejs.</p>
</div>
<hr>
<div class="block">
  <p>Jednym ze sposobów na dodanie metod do obiektów jest po prostu dołączenie do nich funkcji.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">rabbit</span> = {};
    <span class="variable">rabbit</span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="variabledef">line</span>) {
    <span class="variable">print</span>(<span class="string">"Królik powiedział „"</span>, <span class="localvariable">line</span>, <span class="string">"”"</span>);
};

    <span class="variable">rabbit</span>.<span class="property">speak</span>(<span class="string">"Teraz Ty pytasz mnie."</span>);</pre>
  <p>W większości przypadków <strong>metoda</strong> musi wiedzieć, <em>na czym</em> ma działać. Na przykład, jeśli byłoby kilka królików, metoda <code>speak</code> musiałaby wskazywać, który królik ma mówić. Do tego służy specjalna zmienna o nazwie <code>this</code>, która jest zawsze dostępna w wywołaniu funkcji, a jeśli funkcja jest wywoływana jako metoda, wskazuje odpowiedni obiekt. Funkcja nazywa się metodą, gdy należy do obiektu i jest z niego wywoływana, np. <code>object.method()</code>.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">speak</span>(<span class="variabledef">line</span>) {
    <span class="variable">print</span>(<span class="string">"Pewien "</span>, <span class="localvariable">this</span>.<span class="property">adjective</span>, <span class="string">" królik mówi „"</span>, <span class="localvariable">line</span>, <span class="string">"”"</span>);
}
    <span class="keyword">var</span> <span class="variable">whiteRabbit</span> = {<span class="property">adjective</span>: <span class="string">"biały"</span>, <span class="property">speak</span>: <span class="variable">speak</span>};
    <span class="keyword">var</span> <span class="variable">fatRabbit</span> = {<span class="property">adjective</span>: <span class="string">"gruby"</span>, <span class="property">speak</span>: <span class="variable">speak</span>};

    <span class="variable">whiteRabbit</span>.<span class="property">speak</span>(<span class="string">"Na moje uszy i wąsy, która to już godzina!"</span>);
    <span class="variable">fatRabbit</span>.<span class="property">speak</span>(<span class="string">"Nie pogardziłbym jakąś małą marchewką."</span>);</pre>
</div>
<hr>
<div class="block">
  <p>Teraz mogę wyjaśnić do czego służy ten tajemniczy pierwszy argument metody <code>apply</code>, któremu zawsze przypisywaliśmy wartość <code>null</code> w <a href="/kursy/javascript/wszystko-jasne/r6-programowanie-funkcyjne">rozdziale 6</a>. Przy jego użyciu można określić obiekt, do którego ma zostać zastosowana funkcja. W przypadku funkcji niebędących metodami argument ten jest niepotrzebny i dlatego nadawaliśmy mu wartość <code>null</code>.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">speak</span>.<span class="property">apply</span>(<span class="variable">fatRabbit</span>, [<span class="string">"Pycha."</span>]);</pre>
  <p>Funkcje również mają metodę <code>call</code>, która jest podobna do <code>apply</code>, ale przyjmuje argumenty dla funkcji oddzielnie, zamiast w tablicy:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">speak</span>.<span class="property">call</span>(<span class="variable">fatRabbit</span>, <span class="string">"Burp."</span>);</pre>
</div>
<hr>
<div class="block">
  <p>Słowo kluczowe <code>new</code> umożliwia tworzenie obiektów w wygodny sposób. Gdy przed wywołaniem funkcji wstawi się słowo kluczowe <code>new</code>, jej zmienna <code>this</code> wskaże na <em>nowy</em> obiekt, który funkcja automatycznie zwróci (chyba że celowo ma ustawione, aby zwracać coś innego). Funkcje służące do tworzenia nowych obiektów nazywają się konstruktorami. Poniżej znajduje się konstruktor królików:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">Rabbit</span>(<span class="variabledef">adjective</span>) {
    <span class="localvariable">this</span>.<span class="property">adjective</span> = <span class="localvariable">adjective</span>;
    <span class="localvariable">this</span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="variabledef">line</span>) {
    <span class="variable">print</span>(<span class="string">"Pewien "</span>, <span class="localvariable">this</span>.<span class="property">adjective</span>, <span class="string">" królik mówi „"</span>, <span class="localvariable">line</span>, <span class="string">"”"</span>);
  };
}

    <span class="keyword">var</span> <span class="variable">killerRabbit</span> = <span class="keyword">new</span> <span class="variable">Rabbit</span>(<span class="string">"zabójczy"</span>);
    <span class="variable">killerRabbit</span>.<span class="property">speak</span>(<span class="string">"KRAAAAAAAAACH!"</span>);</pre>
  <p>W programowaniu JavaScript istnieje konwencja, zgodnie z którą nazwy konstruktorów rozpoczyna się wielką literą. Dzięki temu łatwo się je odróżnia od innych funkcji.</p>
  <p>Czy słowa kluczowe <code>new</code> jest tak naprawdę potrzebne? Przecież równie dobrze można by było pisać tak:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">makeRabbit</span>(<span class="variabledef">adjective</span>) {
    <span class="keyword">return</span> {
    <span class="property">adjective</span>: <span class="localvariable">adjective</span>,
    <span class="property">speak</span>: <span class="keyword">function</span>(<span class="variabledef">line</span>) {<span class="comment">/*itd.*/</span>}
  };
}

    <span class="keyword">var</span> <span class="variable">blackRabbit</span> = <span class="variable">makeRabbit</span>(<span class="string">"czarny"</span>);</pre>
  <p>To nie jest dokładnie to samo. Słowo kluczowe <code>new</code> wykonuje jeszcze kilka dodatkowych działań, tylko tego nie widać. Nasz obiekt <code>killerRabbit</code> ma własność o nazwie <code>constructor</code> wskazującą funkcję <code>Rabbit</code>, która go utworzyła. Obiekt <code>blackRabbit</code> również ma taką własność, ale wskazującą funkcję <code>Object</code>.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">show</span>(<span class="variable">killerRabbit</span>.<span class="property">constructor</span>);
    <span class="variable">show</span>(<span class="variable">blackRabbit</span>.<span class="property">constructor</span>);</pre>
</div>
<hr>
<div class="block">
  <p>Skąd się wzięła własność <code>constructor</code>? Jest ona częścią prototypu królika. <strong>Prototypy</strong> są potężną, choć trochę zawiłą, częścią systemu obiektowego języka JavaScript. Każdy obiekt bazuje na jakimś prototypie, z którego dziedziczy różne własności. Proste obiekty, których używaliśmy do tej pory bazują na podstawowym prototypie, który jest związany z konstruktorem <code>Object</code>. W istocie wyrażenie <code>{}</code> jest równoważne z <code>new Object()</code>.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">simpleObject</span> = {};
    <span class="variable">show</span>(<span class="variable">simpleObject</span>.<span class="property">constructor</span>);
    <span class="variable">show</span>(<span class="variable">simpleObject</span>.<span class="property">toString</span>);</pre>
  <p>Metoda <code>toString</code> należy do prototypu <code>Object</code>. Oznacza to, że wszystkie proste obiekty mają metodę <code>toString</code>, która konwertuje je na łańcuch. Nasze obiekty królików są utworzone na bazie prototypu związanego z konstruktorem <code>Rabbit</code>. Za pomocą własności <code>prototype</code> konstruktora można nawet uzyskać dostęp do ich prototypu:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">show</span>(<span class="variable">Rabbit</span>.<span class="property">prototype</span>);
    <span class="variable">show</span>(<span class="variable">Rabbit</span>.<span class="property">prototype</span>.<span class="property">constructor</span>);</pre>
  <p>Każdej funkcji automatycznie przypisywana jest własność <code>prototype</code>, której własność <code>constructor</code> wskazuje na tę funkcję. Ponieważ prototyp królika sam jest obiektem, bazuje na prototypie <code>Object</code> i ma jego metodę <code>toString</code>.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">show</span>(<span class="variable">killerRabbit</span>.<span class="property">toString</span> == <span class="variable">simpleObject</span>.<span class="property">toString</span>);</pre>
</div>
<hr>
<div class="block">
  <p>Obiekty dziedziczą własności swoich prototypów, ale dziedziczenie to jest tylko jednostronne. Własności prototypu mają wpływ na obiekt utworzony na bazie tego prototypu, ale własności tego obiektu nie mają wpływu na prototyp.</p>
  <p>Ściśle rzecz biorąc reguła ta brzmi następująco: szukając własności JavaScript najpierw przeszukuje zestaw własności <em>samego</em> obiektu. Jeśli własność o szukanej nazwie zostanie znaleziona, to zostanie użyta. Jeśli własność nie zostanie znaleziona, przeszukiwany jest prototyp obiektu, następnie prototyp prototypu itd. Jeśli nic nie zostanie znalezione, zostaje zwrócona wartość <code>undefined</code>. Z drugiej strony, gdy <em>ustawiana</em> jest wartość własności, JavaScript nigdy nie przechodzi do prototypu, lecz zawsze ustawia własność w samym obiekcie.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Rabbit</span>.<span class="property">prototype</span>.<span class="property">teeth</span> = <span class="string">"małe"</span>;
    <span class="variable">show</span>(<span class="variable">killerRabbit</span>.<span class="property">teeth</span>);
    <span class="variable">killerRabbit</span>.<span class="property">teeth</span> = <span class="string">"długie, ostre i zakrwawione"</span>;
    <span class="variable">show</span>(<span class="variable">killerRabbit</span>.<span class="property">teeth</span>);
    <span class="variable">show</span>(<span class="variable">Rabbit</span>.<span class="property">prototype</span>.<span class="property">teeth</span>);</pre>
  <p>Oznacza to, że za pomocą prototypu można w dowolnej chwili dodać nowe własności i metody do wszystkich bazujących na nim obiektów. Na przykład w trakcie pracy może się okazać, że nasze króliki muszą umieć tańczyć.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Rabbit</span>.<span class="property">prototype</span>.<span class="property">dance</span> = <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">"Pewien "</span>, <span class="localvariable">this</span>.<span class="property">adjective</span>, <span class="string">" królik tańczy gigę."</span>);
};

    <span class="variable">killerRabbit</span>.<span class="property">dance</span>();</pre>
  <p>Jak się pewnie domyślasz, prototyp królika jest doskonałym miejscem na dodawanie wartości wspólnych dla wszystkich królików, takich jak metoda <code>speak</code>. Oto nowa wersja konstruktora <code>Rabbit</code>:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">Rabbit</span>(<span class="variabledef">adjective</span>) {
    <span class="localvariable">this</span>.<span class="property">adjective</span> = <span class="localvariable">adjective</span>;
}
    <span class="variable">Rabbit</span>.<span class="property">prototype</span>.<span class="property">speak</span> = <span class="keyword">function</span>(<span class="variabledef">line</span>) {
    <span class="variable">print</span>(<span class="string">"Pewien "</span>, <span class="localvariable">this</span>.<span class="property">adjective</span>, <span class="string">" królik mówi „"</span>, <span class="localvariable">line</span>, <span class="string">"”"</span>);
};

    <span class="keyword">var</span> <span class="variable">hazelRabbit</span> = <span class="keyword">new</span> <span class="variable">Rabbit</span>(<span class="string">"brązowy"</span>);
    <span class="variable">hazelRabbit</span>.<span class="property">speak</span>(<span class="string">"Dobry Frith!"</span>);</pre>
</div>
<hr>
<div class="block">
  <p>Fakt, że wszystkie obiekty mają prototypy i mogą po nich dziedziczyć różne własności może sprawiać problemy. Oznacza to, że użycie obiektu do przechowywania zbioru wartości, jak w przypadku kotów w <a href="/kursy/javascript/wszystko-jasne/r4-obiekty-tablice">rozdziale 4</a>, może się nie udać. Gdybyśmy np. chcieli sprawdzić czy istnieje kot o imieniu <code>constructor</code>, napisalibyśmy taki kod:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">noCatsAtAll</span> = {};
    <span class="keyword">if</span> (<span class="string">"constructor"</span> in <span class="variable">noCatsAtAll</span>)
    <span class="variable">print</span>(<span class="string">"Tak, niewątpliwie istnieje kot o imieniu „constructor”."</span>);</pre>
  <p>Mamy problem. Dodatkowe trudności może sprawiać fakt, że standardowe prototypy, takie jak <code>Object</code> i <code>Array</code>, często  rozszerza się o nowe przydatne funkcje. Na przykład moglibyśmy wszystkim obiektom dodać metodę o nazwie <code>properties</code> zwracającą tablicę nazw wszystkich nieukrytych własności obiektów:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">properties</span> = <span class="keyword">function</span>() {
    <span class="keyword">var</span> <span class="variabledef">result</span> = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">property</span> <span class="keyword">in</span> <span class="localvariable">this</span>)
    <span class="localvariable">result</span>.<span class="property">push</span>(<span class="localvariable">property</span>);
    <span class="keyword">return</span> <span class="localvariable">result</span>;
};

    <span class="keyword">var</span> <span class="variable">test</span> = {<span class="property">x</span>: <span class="atom">10</span>, <span class="property">y</span>: <span class="atom">3</span>};
    <span class="variable">show</span>(<span class="variable">test</span>.<span class="property">properties</span>());</pre>
  <p>Od razu widać, w czym tkwi problem. Od tej chwili prototyp <code>Object</code> ma własność o nazwie <code>properties</code>, w związku z czym w wyniku iteracji przy użyciu pętli <code>for</code> i <code>in</code> po własnościach jakiegokolwiek obiektu otrzymamy także tę wspólną własność, czego normalnie byśmy nie chcieli. Interesują nas jedynie własności należące tylko do tego obiektu.</p>
  <p>Na szczęście można sprawdzić, czy wybrana własność należy do obiektu, czy do jednego z jego prototypów. Niestety dodatek tego testu sprawia, że kod pętli staje się nieco niezgrabny. Każdy obiekt ma metodę o nazwie <code>hasOwnProperty</code>, która informuje, czy obiekt ma własność o określonej nazwie. Przy jej użyciu naszą metodę <code>properties</code> moglibyśmy przepisać następująco:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">properties</span> = <span class="keyword">function</span>() {
    <span class="keyword">var</span> <span class="variabledef">result</span> = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">property</span> <span class="keyword">in</span> <span class="localvariable">this</span>) {
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">hasOwnProperty</span>(<span class="localvariable">property</span>))
    <span class="localvariable">result</span>.<span class="property">push</span>(<span class="localvariable">property</span>);
  }
    <span class="keyword">return</span> <span class="localvariable">result</span>;
};

    <span class="keyword">var</span> <span class="variable">test</span> = {<span class="string">"Fat Igor"</span>: <span class="atom">true</span>, <span class="string">"Fireball"</span>: <span class="atom">true</span>};
    <span class="variable">show</span>(<span class="variable">test</span>.<span class="property">properties</span>());</pre>
  <p>I oczywiście możemy ją przepisać abstrakcyjnie jako funkcję wyższego rzędu. Zwróć uwagę, że w wywołaniu funkcji <code>action</code> przekazywana jest zarówno nazwa własności jak i jej wartość w obiekcie.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">forEachIn</span>(<span class="variabledef">object</span>, <span class="variabledef">action</span>) {
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">property</span> <span class="keyword">in</span> <span class="localvariable">object</span>) {
    <span class="keyword">if</span> (<span class="localvariable">object</span>.<span class="property">hasOwnProperty</span>(<span class="localvariable">property</span>))
    <span class="localvariable">action</span>(<span class="localvariable">property</span>, <span class="localvariable">object</span>[<span class="localvariable">property</span>]);
  }
}

    <span class="keyword">var</span> <span class="variable">chimera</span> = {<span class="property">głowa</span>: <span class="string">"lwa"</span>, <span class="property">ciało</span>: <span class="string">"kozła"</span>, <span class="property">ogon</span>: <span class="string">"węża"</span>};
    <span class="variable">forEachIn</span>(<span class="variable">chimera</span>, <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">value</span>) {
    <span class="variable">print</span>(<span class="localvariable">name</span>, <span class="string">" "</span>, <span class="localvariable">value</span>, <span class="string">"."</span>);
});</pre>
  <p>Ale co będzie, gdy znajdziemy kota o imieniu <code>hasOwnProperty</code>? (Kto wie, jakie imiona ludzie mogą nadawać swoim kotom). Zostanie ono zapisane w obiekcie i gdy spróbujemy potem przejrzeć kolekcję kotów, wywołanie metody <code>object.hasOwnProperty</code> nie uda się, ponieważ wartość ta nie będzie już wskazywała wartości funkcyjnej. Można to rozwiązać stosując jeszcze mniej eleganckie rozwiązanie:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">forEachIn</span>(<span class="variabledef">object</span>, <span class="variabledef">action</span>) {
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">property</span> <span class="keyword">in</span> <span class="localvariable">object</span>) {
    <span class="keyword">if</span> (<span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">hasOwnProperty</span>.<span class="property">call</span>(<span class="localvariable">object</span>, <span class="localvariable">property</span>))
    <span class="localvariable">action</span>(<span class="localvariable">property</span>, <span class="localvariable">object</span>[<span class="localvariable">property</span>]);
  }
}

    <span class="keyword">var</span> <span class="variable">test</span> = {<span class="property">name</span>: <span class="string">"Mordechai"</span>, <span class="property">hasOwnProperty</span>: <span class="string">"Uh-oh"</span>};
    <span class="variable">forEachIn</span>(<span class="variable">test</span>, <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">value</span>) {
    <span class="variable">print</span>(<span class="string">"Property "</span>, <span class="localvariable">name</span>, <span class="string">" = "</span>, <span class="localvariable">value</span>);
});</pre>
  <p>(Uwaga: ten przykład nie działa w przeglądarce Internet Explorer 8, która najwyraźniej ma trudności z przesłanianiem wbudowanych własności prototypów).</p>
  <p>W tym kodzie zamiast używać metody z obiektu posługujemy się metodą pobraną z prototypu <code>Object</code>, a następnie stosujemy ją do odpowiedniego obiektu za pomocą funkcji <code>call</code>. Jeśli nikt nie nabałagani w tej metodzie w <code>Object.prototype</code> (a nie należy tego robić), to program powinien działać prawidłowo.</p>
</div>
<hr>
<div class="block">
  <p>Metody <code>hasOwnProperty</code> można także używać w tych sytuacjach, w których używaliśmy operatora <code>in</code>, aby dowiedzieć się czy wybrany obiekt ma określoną własność. Jest jednak pewien haczyk. W <a href="/kursy/javascript/wszystko-jasne/r4-obiekty-tablice">rozdziale 4</a> dowiedziałeś się, że niektóre własności, np. <code>toString</code>, są ukryte i pętle <code>for</code>-<code>in</code> ich nie wykrywają. Przeglądarki z rodziny Gecko (przede wszystkim Firefox) każdemu obiektowi przypisują ukrytą własność o nazwie <code>__proto__</code> wskazującą prototyp tego obiektu. Dla niej metoda <code>hasOwnProperty</code> również zwróci <code>true</code>, mimo że nie została dodana bezpośrednio przez program. Dostęp do prototypu obiektu bywa przydatny, ale realizowanie tego w postaci własności nie było najlepszym pomysłem. Niemniej jednak Firefox to bardzo popularna przeglądarka, a więc pisząc aplikację sieciową trzeba o tym pamiętać. Istnieje też metoda o nazwie <code>propertyIsEnumerable</code>, która zwraca <code>false</code> dla ukrytych własności i za pomocą której można odfiltrować takie dziwadła, jak <code>__proto__</code>. Poniższe wyrażenie jest dobrym sposobem na obejście omawianego problemu:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">object</span> = {<span class="property">foo</span>: <span class="string">"bar"</span>};
    <span class="variable">show</span>(<span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">hasOwnProperty</span>.<span class="property">call</span>(<span class="variable">object</span>, <span class="string">"foo"</span>) &amp;&amp;
    <span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">propertyIsEnumerable</span>.<span class="property">call</span>(<span class="variable">object</span>, <span class="string">"foo"</span>));</pre>
  <p>Proste i eleganckie, prawda? Jest to jedna z tych słabszych stron projektu JavaScriptu. Obiekty pełnią zarówno rolę „wartości z metodami”, dla których prototypy są pożyteczne jak i „zbiorów własności”, którym prototypy tylko przeszkadzają.</p>
</div>
<hr>
<div class="block">
  <p>Wpisywanie powyższego wyrażenia, za każdym razem gdy trzeba sprawdzić, czy obiekt zawiera jakąś własność jest niewykonalne. Moglibyśmy zdefiniować funkcję, ale jeszcze lepszym rozwiązaniem jest napisanie konstruktora i prototypu specjalnie na okazje, gdy obiekt chcemy traktować jako zestaw własności. Ponieważ można w nim wyszukiwać wartości po nazwach, nazwiemy go <code>Dictionary</code> (słownik).</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">Dictionary</span>(<span class="variabledef">startValues</span>) {
    <span class="localvariable">this</span>.<span class="property">values</span> = <span class="localvariable">startValues</span> || {};
}
    <span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">store</span> = <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">value</span>) {
    <span class="localvariable">this</span>.<span class="property">values</span>[<span class="localvariable">name</span>] = <span class="localvariable">value</span>;
};
    <span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">lookup</span> = <span class="keyword">function</span>(<span class="variabledef">name</span>) {
    <span class="keyword">return</span> <span class="localvariable">this</span>.<span class="property">values</span>[<span class="localvariable">name</span>];
};
    <span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">contains</span> = <span class="keyword">function</span>(<span class="variabledef">name</span>) {
    <span class="keyword">return</span> <span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">hasOwnProperty</span>.<span class="property">call</span>(<span class="localvariable">this</span>.<span class="property">values</span>, <span class="localvariable">name</span>) &amp;&amp;
    <span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">propertyIsEnumerable</span>.<span class="property">call</span>(<span class="localvariable">this</span>.<span class="property">values</span>, <span class="localvariable">name</span>);
};
    <span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">each</span> = <span class="keyword">function</span>(<span class="variabledef">action</span>) {
    <span class="variable">forEachIn</span>(<span class="localvariable">this</span>.<span class="property">values</span>, <span class="localvariable">action</span>);
};

    <span class="keyword">var</span> <span class="variable">colours</span> = <span class="keyword">new</span> <span class="variable">Dictionary</span>({<span class="property">Grover</span>: <span class="string">"niebieski"</span>,
    <span class="property">Elmo</span>: <span class="string">"pomarańczowy"</span>,
    <span class="property">Bert</span>: <span class="string">"żółty"</span>});
    <span class="variable">show</span>(<span class="variable">colours</span>.<span class="property">contains</span>(<span class="string">"Grover"</span>));
    <span class="variable">show</span>(<span class="variable">colours</span>.<span class="property">contains</span>(<span class="string">"constructor"</span>));
    <span class="variable">colours</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">colour</span>) {
    <span class="variable">print</span>(<span class="localvariable">name</span>, <span class="string">" jest "</span>, <span class="localvariable">colour</span>);
});</pre>
  <p>Cały mechanizm wykorzystania obiektów jako zbiorów własności został zamknięty w wygodnym interfejsie: jeden konstruktor i cztery metody. Zauważ, że własność <code>values</code> obiektu <code>Dictionary</code> nie należy do tego interfejsu, tylko jest wewnętrznym szczegółem, którego nie używa się bezpośrednio podczas korzystania z obiektów typu <code>Dictionary</code>.</p>
  <p>Do każdego tworzonego przez siebie interfejsu powinno dodać się krótki komentarz opisujący sposób jego działania i użycia. Dzięki temu, gdy za kilka miesięcy ktoś (może Ty sam) zechce go użyć, będzie mógł szybko przeczytać instrukcję obsługi zamiast studiować kod.</p>
  <p>Zazwyczaj krótko po zaprojektowaniu interfejsu odkrywa się jego ograniczenia i usterki, które należy zmienić. Dlatego dla oszczędności czasu zaleca się dokumentowanie interfejsów dopiero <em>po</em> pewnym czasie ich użytkowania, gdy zostanie udowodnione, że są praktyczne. Oczywiście to może być pokusą, aby w ogóle zapomnieć o pisaniu dokumentacji. Sam robienie tego traktuję jako czynność wykończeniową podczas prac nad systemem. Gdy interfejs jest gotowy, po prostu stwierdzam, że czas coś o nim napisać, aby przekonać się, że jego opis w języku ludzkim brzmi równie dobrze, jak w języku JavaScript (lub jakimkolwiek innym języku programowania, jakiego używamy).</p>
</div>
<hr>
<div class="block">
  <p>Rozróżnienie zewnętrznego interfejsu i wewnętrznych szczegółów obiektu jest ważne z dwóch powodów. Po pierwsze dzięki niewielkiemu i ściśle zdefiniowane interfejsowi obiekt jest łatwy w użyciu. Trzeba tylko znać ten interfejs, a resztę kodu obiektu nie musimy się interesować, chyba że chcemy coś w nim zmienić.</p>
  <p>Po drugie często zdarza się, że trzeba coś zmienić w wewnętrznej implementacji obiektu, aby był bardziej praktyczny, lepiej działał albo żeby usunąć usterkę. Gdyby w innych częściach programu używane były wszystkie własności i elementy budowy obiektu, nie można by było w nim nic zmienić bez dodatkowego modyfikowania dużych partii kodu w innych miejscach. Jeśli na zewnętrz obiektu używany jest tylko jego niewielki interfejs, można wprowadzać dowolne zmiany w implementacji, pod warunkiem, że nie rusza się tego interfejsu.</p>
  <p>Niektórzy traktują to niezwykle poważnie. Osoby takie np. w interfejsach obiektów nigdy nie umieszczają własności, a jedynie metody — jeśli ich typ obiektowy ma długość, to jest ona dostępna poprzez metodę <code>getLength</code>, a nie własność <code>length</code>. Dzięki temu, jeśli kiedyś zechcą ze swojego obiektu usunąć własność <code>length</code>, bo np. od tej pory zawiera on wewnętrzną tablicę, której długość musi zwracać, mogą zmodyfikować funkcję bez zmieniania interfejsu.</p>
  <p>Jednak moim zdaniem nie jest to warte zachodu. Dodanie metody o nazwie <code>getLength</code>, która zawiera tylko instrukcję <code>return this.length;</code> jest niepotrzebnym mnożeniem kodu. Dla mnie w większości przypadków taki bezsensowny kod jest większym problemem niż konieczność zmiany interfejsu raz na gody.</p>
</div>
<hr>
<div class="block">
  <p>Bardzo przydatne jest dodawanie nowych metod do istniejących prototypów. W języku JavaScript dodatkowe metody przydałyby się prototypom <code>Array</code> i <code>String</code>. Moglibyśmy np. zamienić funkcje <code>forEach</code> i <code>map</code> metodami tablic, a funkcję <code>startsWith</code> napisaną w <a href="/kursy/javascript/wszystko-jasne/r4-obiekty-tablice">rozdziale 4</a> zamienić w metodę łańcuchów.</p>
  <p>Jeśli jednak Twój program będzie działał na jednej stronie internetowej z innym programem, w którym programista używa konstrukcji <code>for</code>-<code>in</code> naiwnie ― czyli tak, jak my do tej pory ― to dodanie metod do prototypów, zwłaszcza <code>Object</code> i <code>Array</code>, na pewno spowoduje problemy, ponieważ pętle te nagle zaczną znajdować nowe własności. Dlatego niektórzy wolą w ogóle nie ruszać tych prototypów. Oczywiście jeśli jesteś ostrożny i nie spodziewasz się, że Twój kod będzie pracował obok jakiegoś źle napisanego programu, dodawanie metod do standardowych prototypów jest jak najbardziej wartościową techniką.</p>
</div>
<hr>
<div class="block">
  <p>W tym rozdziale zbudujemy wirtualne terrarium, czyli pojemnik zawierający fruwające owady. W programie tym będziemy używać obiektów, co chyba Cię nie dziwi, skoro temat tego rozdziału to programowanie obiektowe w JavaScript. Nie będziemy tworzyć niczego skomplikowanego. Nasze terrarium będzie dwuwymiarową siatką, jak druga mapa w <a href="/kursy/javascript/wszystko-jasne/r7-wyszukiwanie">rozdziale 7</a>. Na siatce rozmieszczone są owady. Gdy terrarium jest aktywne, każdy owad może wykonać jakąś czynność, np poruszyć się co pół sekundy.</p>
  <p>W związku z tym podzielimy przestrzeń i czas na jednostki o stałym rozmiarze ― kwadraty dla przestrzeni i połówki sekund dla czasu. Zaletą tego jest uproszczenie modelowania w programie, a wadą niska precyzja. Na szczęście w tym symulatorze terrarium nic nie musi być precyzyjne, a więc nie ma problemu.</p>
</div>
<hr>
<div class="block">
  <p>Terrarium można zdefiniować przy użyciu szablonu będącego tablicą łańcuchów. Moglibyśmy użyć pojedynczego łańcucha, ale ponieważ w JavaScripcie łańcuchy muszą w całości mieścić się w jednym wierszu, byłoby to trudne do zrealizowania.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">thePlan</span> =
  [<span class="string">"############################"</span>,
    <span class="string">"#      #    #      o      ##"</span>,
    <span class="string">"#                          #"</span>,
    <span class="string">"#          #####           #"</span>,
    <span class="string">"##         #   #    ##     #"</span>,
    <span class="string">"###           ##     #     #"</span>,
    <span class="string">"#           ###      #     #"</span>,
    <span class="string">"#   ####                   #"</span>,
    <span class="string">"#   ##       o             #"</span>,
    <span class="string">"# o  #         o       ### #"</span>,
    <span class="string">"#    #                     #"</span>,
    <span class="string">"############################"</span>];</pre>
  <p>Znaki <code>#</code> reprezentują ściany terrarium (i znajdujące się w nim ozdobne kamienie), znaki <code>o</code> reprezentują owady, a spacje, jak się pewnie domyślasz oznaczają puste miejsce.</p>
  <p>Z takiej tablicy można utworzyć obiekt terrarium. W obiekcie tym przechowywane będą kształt i zawartość terrarium oraz będzie on umożliwiał poruszanie się owadom. Obiekt ma cztery metody: Pierwsza to <code>toString</code>, która konwertuje terrarium na łańcuch podobny do bazowego planu, dzięki czemu można zobaczyć, co się dzieje wewnątrz. Metoda <code>step</code> pozwala owadom wykonać pojedynczy ruch, jeśli sobie tego życzą. Natomiast metody <code>start</code> i <code>stop</code> służą do „włączania” i wyłączania” terrarium. Gdy terrarium jest uruchomione, metoda <code>step</code> jest wywoływana automatycznie co pół sekundy powodując ruch owadów.</p>
</div>
<hr>
<div class="block">
  <div class="exercisenum">Ćwiczenie 8.1</div>
  <div class="exercise">
    <p>Punkty na siatce także będą reprezentowane jako obiekty. W <a href="/kursy/javascript/wszystko-jasne/r7-wyszukiwanie">rozdziale 7</a> do pracy z punktami używane były trzy funkcje: <code>point</code>, <code>addPoints</code> oraz <code>samePoint</code>. Tym razem użyjemy konstruktora i dwóch metod. Napisz konstruktor <code>Point</code> pobierający dwa argumenty będące współrzędnymi x i y punktu i tworzący obiekt zawierający własności <code>x</code> i <code>y</code>. Prototypowi tego konstruktora dodaj metodę <code>add</code> pobierającą punkt jako argument i zwracającą <em>nowy</em> punkt, którego współrzędne <code>x</code> i <code>y</code> są sumą współrzędnych <code>x</code> i <code>y</code> dwóch podanych punktów. Dodatkowo napisz metodę <code>isEqualTo</code> pobierającą punkt i zwracającą wartość logiczną oznaczającą, czy ten (<code>this</code>) punkt ma takie same współrzędne, jak podany punkt.</p>
    <p>Oprócz wymienionych dwóch metod w skład interfejsu tego typu obiektów wchodzą również własności <code>x</code> i <code>y</code>: Kod używający obiektów punktów może dowolnie pobierać i modyfikować własności <code>x</code> i <code>y</code>.</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">Point</span>(<span class="variabledef">x</span>, <span class="variabledef">y</span>) {
      <span class="localvariable">this</span>.<span class="property">x</span> = <span class="localvariable">x</span>;
      <span class="localvariable">this</span>.<span class="property">y</span> = <span class="localvariable">y</span>;
}
      <span class="variable">Point</span>.<span class="property">prototype</span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="variabledef">other</span>) {
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">Point</span>(<span class="localvariable">this</span>.<span class="property">x</span> + <span class="localvariable">other</span>.<span class="property">x</span>, <span class="localvariable">this</span>.<span class="property">y</span> + <span class="localvariable">other</span>.<span class="property">y</span>);
};
      <span class="variable">Point</span>.<span class="property">prototype</span>.<span class="property">isEqualTo</span> = <span class="keyword">function</span>(<span class="variabledef">other</span>) {
      <span class="keyword">return</span> <span class="localvariable">this</span>.<span class="property">x</span> == <span class="localvariable">other</span>.<span class="property">x</span> &amp;&amp; <span class="localvariable">this</span>.<span class="property">y</span> == <span class="localvariable">other</span>.<span class="property">y</span>;
};

      <span class="variable">show</span>((<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">3</span>, <span class="atom">1</span>)).<span class="property">add</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">2</span>, <span class="atom">4</span>)));</pre>
    <p>Pamiętaj, aby Twoja wersja metody <code>add</code> pozostawiała punkt <code>this</code> nietknięty i tworzyła nowy obiekt. Metoda zmieniająca bieżący obiekt działałaby podobnie do operatora <code>+=</code>, który z kolei działa jak operator <code>+</code>.</p>
  </div>
</div>
<hr>
<div class="block">
  <p>Podczas pisania obiektów do implementacji programu nie zawsze jest jasne, gdzie powinny być zaimplementowane różne funkcje. Niektóre rzeczy najlepiej jest zrealizować jako metody obiektów, inne lepiej wyrazić jako osobne funkcje, a jeszcze inne najlepiej jest zaimplementować poprzez dodanie nowego typu obiektowego. Aby kod był klarowny i dobrze zorganizowany, należy starać się liczbę metod i obowiązków obiektów sprowadzić do minimum. Gdy obiekt wykonuje zbyt wiele zadań, robi się w nim bałagan, który bardzo trudno zrozumieć.</p>
  <p>Wcześniej napisałem, że obiekt terrarium będzie odpowiedzialny za przechowywanie zawartości terrarium i możliwość ruchu owadów. Należy podkreślić słowo <em>możliwość</em>, które nie oznacza <em>przymusu</em>. Same owady też będą obiektami i w ich gestii będzie leżeć podejmowanie decyzji, co w danym momencie zrobić. Terrarium umożliwia zaledwie pytanie owadów, czy chcą coś zrobić co pół sekundy i jeśli owad zechce się poruszyć, terrarium zadba o to, aby tak się stało.</p>
  <p>Przechowywanie siatki, na której rozmieszczona jest zawartość terrarium może być skomplikowane. Trzeba zdefiniować jakąś reprezentację, sposoby dostępu do tej reprezentacji, sposób inicjacji siatki z tablicowego planu, sposób zapisania zawartości siatki w łańcuchu za pomocą metody <code>toString</code> oraz ruch owadów na siatce. Dobrze by było przynajmniej część tych obowiązków przenieść na inny obiekt, aby obiekt terrarium nie stał się zbyt rozbudowany.</p>
</div>
<hr>
<div class="block">
  <p>Zawsze gdy natkniesz się na problem pomieszania reprezentacji danych i kodu implementacyjnego w jednym obiekcie, dobrym pomysłem jest wydzielenie kodu dotyczącego reprezentacji danych do osobnego typu obiektu. W tym przypadku potrzebujemy reprezentacji siatki wartości, a więc napisałem typ o nazwie <code>Grid</code> obsługujący operacje wymagane przez terrarium.</p>
  <p>Wartości na siatce można zapisywać na dwa sposoby: Można użyć tablicy tablic:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">grid</span> = [[<span class="string">"0,0"</span>, <span class="string">"1,0"</span>, <span class="string">"2,0"</span>],
            [<span class="string">"0,1"</span>, <span class="string">"1,1"</span>, <span class="string">"2,1"</span>]];
    <span class="variable">show</span>(<span class="variable">grid</span>[<span class="atom">1</span>][<span class="atom">2</span>]);</pre>
  <p>Ale można też wszystkie wartości umieścić w jednej tablicy. W tym przypadku element o współrzędnych <code>x</code>,<code>y</code> można znaleźć pobierając element znajdujący się w tablicy na pozycji <code>x + y * width</code>, gdzie <code>width</code> to szerokość siatki.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">grid</span> = [<span class="string">"0,0"</span>, <span class="string">"1,0"</span>, <span class="string">"2,0"</span>,
    <span class="string">"0,1"</span>, <span class="string">"1,1"</span>, <span class="string">"2,1"</span>];
    <span class="variable">show</span>(<span class="variable">grid</span>[<span class="atom">2</span> + <span class="atom">1</span> * <span class="atom">3</span>]);</pre>
  <p>Zdecydowałem się na drugie z przedstawionych rozwiązań, ponieważ o wiele łatwiej jest w nim zainicjować tablicę. Instrukcja <code>new Array(x)</code> tworzy nową tablicę o długości <code>x</code>, wypełnioną wartościami <code>undefined</code>.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">Grid</span>(<span class="variabledef">width</span>, <span class="variabledef">height</span>) {
    <span class="localvariable">this</span>.<span class="property">width</span> = <span class="localvariable">width</span>;
    <span class="localvariable">this</span>.<span class="property">height</span> = <span class="localvariable">height</span>;
    <span class="localvariable">this</span>.<span class="property">cells</span> = <span class="keyword">new</span> <span class="variable">Array</span>(<span class="localvariable">width</span> * <span class="localvariable">height</span>);
}
    <span class="variable">Grid</span>.<span class="property">prototype</span>.<span class="property">valueAt</span> = <span class="keyword">function</span>(<span class="variabledef">point</span>) {
    <span class="keyword">return</span> <span class="localvariable">this</span>.<span class="property">cells</span>[<span class="localvariable">point</span>.<span class="property">y</span> * <span class="localvariable">this</span>.<span class="property">width</span> + <span class="localvariable">point</span>.<span class="property">x</span>];
};
    <span class="variable">Grid</span>.<span class="property">prototype</span>.<span class="property">setValueAt</span> = <span class="keyword">function</span>(<span class="variabledef">point</span>, <span class="variabledef">value</span>) {
    <span class="localvariable">this</span>.<span class="property">cells</span>[<span class="localvariable">point</span>.<span class="property">y</span> * <span class="localvariable">this</span>.<span class="property">width</span> + <span class="localvariable">point</span>.<span class="property">x</span>] = <span class="localvariable">value</span>;
};
    <span class="variable">Grid</span>.<span class="property">prototype</span>.<span class="property">isInside</span> = <span class="keyword">function</span>(<span class="variabledef">point</span>) {
    <span class="keyword">return</span> <span class="localvariable">point</span>.<span class="property">x</span> &gt;= <span class="atom">0</span> &amp;&amp; <span class="localvariable">point</span>.<span class="property">y</span> &gt;= <span class="atom">0</span> &amp;&amp;
    <span class="localvariable">point</span>.<span class="property">x</span> &lt; <span class="localvariable">this</span>.<span class="property">width</span> &amp;&amp; <span class="localvariable">point</span>.<span class="property">y</span> &lt; <span class="localvariable">this</span>.<span class="property">height</span>;
};
    <span class="variable">Grid</span>.<span class="property">prototype</span>.<span class="property">moveValue</span> = <span class="keyword">function</span>(<span class="variabledef">from</span>, <span class="variabledef">to</span>) {
    <span class="localvariable">this</span>.<span class="property">setValueAt</span>(<span class="localvariable">to</span>, <span class="localvariable">this</span>.<span class="property">valueAt</span>(<span class="localvariable">from</span>));
    <span class="localvariable">this</span>.<span class="property">setValueAt</span>(<span class="localvariable">from</span>, <span class="atom">undefined</span>);
};</pre>
</div>
<hr>
<div class="block">
  <div class="exercisenum">Ćwiczenie 8.2</div>
  <div class="exercise">
    <p>Będziemy też potrzebować sposobu na przeglądanie wszystkich elementów siatki, aby znaleźć owady, które mają się poruszyć i przekonwertować całość na łańcuch. Najłatwiej będzie napisać funkcję wyższego rzędu pobierającą jako argument akcję. Dodaj metodę <code>each</code> do prototypu <code>Grid</code>, która jako argument będzie pobierać funkcję dwóch argumentów. Metoda będzie wywoływać tę funkcję dla każdego punktu na siatce przekazując jej jako pierwszy argument obiekt tego punktu, a jako drugi argument — wartość znajdującą się w tym punkcie na siatce.</p>
    <p>Przeglądanie rozpocznij w punkcie <code>0</code>,<code>0</code> i przeglądaj po jednym wierszu, tzn. tak, aby punkt <code>1</code>,<code>0</code> został odwiedzony wcześniej niż <code>0</code>,<code>1</code>. To ułatwi późniejsze napisanie funkcji <code>toString</code> terrarium. (Podpowiedź: pętlę <code>for</code> dla współrzędnej <code>x</code> umieść wewnątrz pętli dla współrzędnej <code>y</code>.)</p>
    <p>Lepiej jest nie kombinować bezpośrednio z własnością <code>cells</code> obiektu siatki, tylko zamiast tego do wartości dostać się używając <code>valueAt</code>. Dzięki temu, jeśli postanowimy do zapisywania wartości użyć innej metody, będziemy musieli przepisać tylko <code>valueAt</code> i <code>setValueAt</code>, a pozostałe metody pozostawić bez zmian.</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Grid</span>.<span class="property">prototype</span>.<span class="property">each</span> = <span class="keyword">function</span>(<span class="variabledef">action</span>) {
      <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">y</span> = <span class="atom">0</span>; <span class="localvariable">y</span> &lt; <span class="localvariable">this</span>.<span class="property">height</span>; <span class="localvariable">y</span>++) {
      <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">x</span> = <span class="atom">0</span>; <span class="localvariable">x</span> &lt; <span class="localvariable">this</span>.<span class="property">width</span>; <span class="localvariable">x</span>++) {
      <span class="keyword">var</span> <span class="variabledef">point</span> = <span class="keyword">new</span> <span class="variable">Point</span>(<span class="localvariable">x</span>, <span class="localvariable">y</span>);
      <span class="localvariable">action</span>(<span class="localvariable">point</span>, <span class="localvariable">this</span>.<span class="property">valueAt</span>(<span class="localvariable">point</span>));
    }
  }
};</pre>
  </div>
</div>
<hr>
<div class="block">
  <p>Przetestujemy siatkę:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">testGrid</span> = <span class="keyword">new</span> <span class="variable">Grid</span>(<span class="atom">3</span>, <span class="atom">2</span>);
    <span class="variable">testGrid</span>.<span class="property">setValueAt</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">1</span>, <span class="atom">0</span>), <span class="string">"#"</span>);
    <span class="variable">testGrid</span>.<span class="property">setValueAt</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">1</span>, <span class="atom">1</span>), <span class="string">"o"</span>);
    <span class="variable">testGrid</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">point</span>, <span class="variabledef">value</span>) {
    <span class="variable">print</span>(<span class="localvariable">point</span>.<span class="property">x</span>, <span class="string">","</span>, <span class="localvariable">point</span>.<span class="property">y</span>, <span class="string">": "</span>, <span class="localvariable">value</span>);
});</pre>
</div>
<hr>
<div class="block">
  <p>Zanim napiszemy konstruktor <code>Terrarium</code>, musimy skonkretyzować obiekty owadów, które mają w nim żyć. Wcześniej napisałem, że terrarium będzie pytać owady, jaką czynność chcą wykonać. Będzie się to odbywać następująco: każdy obiekt owada będzie miał metodę <code>act</code> zwracającą „akcję”. Akcja to obiekt zawierający własność <code>type</code> określającą nazwę typu czynności, jaką owad chce wykonać, np. <code>move</code> (ruch). Większość akcji zawiera dodatkowe informacje, takie jak kierunek, w jakim owad chce się poruszyć.</p>
  <p>Owady są niezwykle krótkowzroczne, przez co widzą tylko kwadraty znajdujące się w ich bezpośrednim sąsiedztwie. Ale to wystarczy, aby wykonać ruch. Przy wywoływaniu metodzie <code>act</code> będzie przekazywany obiekt zawierający informacje o otoczeniu określonego owada. W obiekcie tym będzie znajdować się własność dla każdego z ośmiu kierunków. Własność wskazująca, co znajduje się powyżej będzie miała nazwę <code>n</code> (od <span lang="en">North</span> — północ), własność kierunku w górę i na prawo będzie się nazywała <code>ne</code> (od <span lang="en">North-East</span> itd.). Kierunki, do których odnoszą się poszczególne nazwy można znaleźć w poniższym obiekcie słownikowym:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">directions</span> = <span class="keyword">new</span> <span class="variable">Dictionary</span>(
  {<span class="string">"n"</span>:  <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">0</span>, -<span class="atom">1</span>),
    <span class="string">"ne"</span>: <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">1</span>, -<span class="atom">1</span>),
    <span class="string">"e"</span>:  <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">1</span>,  <span class="atom">0</span>),
    <span class="string">"se"</span>: <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">1</span>,  <span class="atom">1</span>),
    <span class="string">"s"</span>:  <span class="keyword">new</span> <span class="variable">Point</span>( <span class="atom">0</span>,  <span class="atom">1</span>),
    <span class="string">"sw"</span>: <span class="keyword">new</span> <span class="variable">Point</span>(-<span class="atom">1</span>,  <span class="atom">1</span>),
    <span class="string">"w"</span>:  <span class="keyword">new</span> <span class="variable">Point</span>(-<span class="atom">1</span>,  <span class="atom">0</span>),
    <span class="string">"nw"</span>: <span class="keyword">new</span> <span class="variable">Point</span>(-<span class="atom">1</span>, -<span class="atom">1</span>)});

    <span class="variable">show</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">4</span>, <span class="atom">4</span>).<span class="property">add</span>(<span class="variable">directions</span>.<span class="property">lookup</span>(<span class="string">"se"</span>)));</pre>
  <p>Gdy owad postanowi się poruszyć, wskaże interesujący go kierunek nadając powstałemu w wyniku tej decyzji obiektowi akcji własność <code>direction</code> zawierającą nazwę jednego z kierunków. Możemy też zrobić głupiego owada, który zawsze porusza się w jednym kierunku — do światła:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">StupidBug</span>() {};
    <span class="variable">StupidBug</span>.<span class="property">prototype</span>.<span class="property">act</span> = <span class="keyword">function</span>(<span class="variabledef">surroundings</span>) {
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"move"</span>, <span class="property">direction</span>: <span class="string">"s"</span>};
};</pre>
</div>
<hr>
<div class="block">
  <p>Teraz może rozpocząć pracę nad obiektem <code>Terrarium</code>. Zaczniemy od konstruktora, który będzie przyjmował plan (będący tablicą łańcuchów)  jako argument i inicjował jego siatkę.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">wall</span> = {};

    <span class="keyword">function</span> <span class="variable">Terrarium</span>(<span class="variabledef">plan</span>) {
    <span class="keyword">var</span> <span class="variabledef">grid</span> = <span class="keyword">new</span> <span class="variable">Grid</span>(<span class="localvariable">plan</span>[<span class="atom">0</span>].<span class="property">length</span>, <span class="localvariable">plan</span>.<span class="property">length</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">y</span> = <span class="atom">0</span>; <span class="localvariable">y</span> &lt; <span class="localvariable">plan</span>.<span class="property">length</span>; <span class="localvariable">y</span>++) {
    <span class="keyword">var</span> <span class="variabledef">line</span> = <span class="localvariable">plan</span>[<span class="localvariable">y</span>];
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">x</span> = <span class="atom">0</span>; <span class="localvariable">x</span> &lt; <span class="localvariable">line</span>.<span class="property">length</span>; <span class="localvariable">x</span>++) {
    <span class="localvariable">grid</span>.<span class="property">setValueAt</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="localvariable">x</span>, <span class="localvariable">y</span>),
    <span class="variable">elementFromCharacter</span>(<span class="localvariable">line</span>.<span class="property">charAt</span>(<span class="localvariable">x</span>)));
    }
  }
    <span class="localvariable">this</span>.<span class="property">grid</span> = <span class="localvariable">grid</span>;
}

    <span class="keyword">function</span> <span class="variable">elementFromCharacter</span>(<span class="variabledef">character</span>) {
    <span class="keyword">if</span> (<span class="localvariable">character</span> == <span class="string">" "</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">character</span> == <span class="string">"#"</span>)
    <span class="keyword">return</span> <span class="variable">wall</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">character</span> == <span class="string">"o"</span>)
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">StupidBug</span>();
}</pre>
  <p><code>wall</code> to obiekt służący do oznaczania ścian siatki. Jak na ścianę przystało, nic nie robi, tylko stoi w jednym miejscu i nie pozwala przejść.</p>
</div>
<hr>
<div class="block">
  <p>Najprostszą metodą obiektu jest <code>toString</code>, która zamienia terrarium w łańcuch. Aby sobie ułatwić, zaznaczymy <code>wall</code> i prototyp owada <code>StupidBug</code> własnością <code>character</code> zawierającą znak reprezentujący owady.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">wall</span>.<span class="property">character</span> = <span class="string">"#"</span>;
    <span class="variable">StupidBug</span>.<span class="property">prototype</span>.<span class="property">character</span> = <span class="string">"o"</span>;

    <span class="keyword">function</span> <span class="variable">characterFromElement</span>(<span class="variabledef">element</span>) {
    <span class="keyword">if</span> (<span class="localvariable">element</span> == <span class="atom">undefined</span>)
    <span class="keyword">return</span> <span class="string">" "</span>;
    <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">element</span>.<span class="property">character</span>;
}

    <span class="variable">show</span>(<span class="variable">characterFromElement</span>(<span class="variable">wall</span>));</pre>
</div>
<hr>
<div class="block">
  <div class="exercisenum">Ćwiczenie 8.3</div>
  <div class="exercise">
    <p>Teraz do utworzenia łańcucha możemy użyć metody <code>each</code> obiektu <code>Grid</code>. Jednak aby wynik był czytelny, przydałoby się na końcu każdego wiersza dodać znak nowego wiersza. Końce rzędów można znaleźć po współrzędnej <code>x</code> pozycji na siatce. Dodaj do prototypu <code>Terrarium</code> metodę <code>toString</code>, która nie pobiera żadnych argumentów i zwraca łańcuch, który po przekazaniu do funkcji <code>print</code> prezentuje się jako dwuwymiarowy widok terrarium.</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">toString</span> = <span class="keyword">function</span>() {
      <span class="keyword">var</span> <span class="variabledef">characters</span> = [];
      <span class="keyword">var</span> <span class="variabledef">endOfLine</span> = <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">width</span> - <span class="atom">1</span>;
      <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">point</span>, <span class="variabledef">value</span>) {
      <span class="localvariable">characters</span>.<span class="property">push</span>(<span class="variable">characterFromElement</span>(<span class="localvariable">value</span>));
      <span class="keyword">if</span> (<span class="localvariable">point</span>.<span class="property">x</span> == <span class="localvariable">endOfLine</span>)
      <span class="localvariable">characters</span>.<span class="property">push</span>(<span class="string">"\n"</span>);
  });
      <span class="keyword">return</span> <span class="localvariable">characters</span>.<span class="property">join</span>(<span class="string">""</span>);
};</pre>
    <p>Wypróbuj ten kod…</p>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">Terrarium</span>(<span class="variable">thePlan</span>);
      <span class="variable">print</span>(<span class="variable">terrarium</span>.<span class="property">toString</span>());</pre>
  </div>
</div>
<hr>
<div class="block">
  <p>Niewykluczone, że próbując rozwiązać powyższe zadanie próbowałeś uzyskać dostęp do <code>this.grid</code> wewnątrz funkcji przekazywanej jako argument do metody <code>each</code> siatki. To się nie uda. Wywołanie funkcji zawsze powoduje powstanie nowej zmiennej <code>this</code> wewnątrz tej funkcji, nawet jeśli nie jest ona używana jako metoda. Przez to żadna zmienna <code>this</code> z poza funkcji nie będzie widoczna.</p>
  <p>czasami problem ten można łatwo obejść zapisując potrzebne informacje w zmiennej, np. <code>endOfLine</code>, która <em>jest</em> widoczna w funkcji wewnętrznej. Jeśli potrzebujesz dostępu do całego obiektu <code>this</code>, to jego również możesz zapisać w zmiennej. Zmiennej takiej często nadaje się nazwę <code>self</code> (albo <code>that</code>).</p>
  <p>Jednak w działaniach tych można się w końcu pogubić. Innym dobrym rozwiązaniem jest użycie funkcji podobnej do <code>partial</code> z <a href="/kursy/javascript/wszystko-jasne/r6-programowanie-funkcyjne">rozdziału 6</a>. Zamiast dodawać argumenty do funkcji, ta dodaje obiekt <code>this</code> używając pierwszego argumentu metody <code>apply</code> funkcji:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">bind</span>(<span class="variabledef">func</span>, <span class="variabledef">object</span>) {
    <span class="keyword">return</span> <span class="keyword">function</span>(){
    <span class="keyword">return</span> <span class="localvariable">func</span>.<span class="property">apply</span>(<span class="localvariable">object</span>, <span class="localvariable">arguments</span>);
  };
}

    <span class="keyword">var</span> <span class="variable">testArray</span> = [];
    <span class="keyword">var</span> <span class="variable">pushTest</span> = <span class="variable">bind</span>(<span class="variable">testArray</span>.<span class="property">push</span>, <span class="variable">testArray</span>);
    <span class="variable">pushTest</span>(<span class="string">"A"</span>);
    <span class="variable">pushTest</span>(<span class="string">"B"</span>);
    <span class="variable">show</span>(<span class="variable">testArray</span>);</pre>
  <p>W ten sposób można powiązać (<code>bind</code>) wewnętrzną funkcję z <code>this</code> i będzie ona miała tę samą zmienną <code>this</code>, co funkcja zewnętrzna.</p>
</div>
<hr>
<div class="block">
  <div class="exercisenum">Ćwiczenie 8.4</div>
  <div class="exercise">
    <p>W wyrażeniu <code>bind(testArray.push, testArray)</code> nazwa <code>testArray</code> występuje dwa razy. Potrafisz zaprojektować funkcję o nazwie <code>method</code> pozwalającą powiązać obiekt z jedną z jego metod <em>bez</em> podawania nazwy obiektu dwa razy?</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <p>Nazwę metody można przekazać jako łańcuch. Dzięki temu funkcja <code>method</code> może sama znaleźć odpowiednią wartość funkcyjną.</p>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">method</span>(<span class="variabledef">object</span>, <span class="variabledef">name</span>) {
      <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="localvariable">object</span>[<span class="localvariable">name</span>].<span class="property">apply</span>(<span class="localvariable">object</span>, <span class="localvariable">arguments</span>);
  };
}

      <span class="keyword">var</span> <span class="variable">pushTest</span> = <span class="variable">method</span>(<span class="variable">testArray</span>, <span class="string">"push"</span>);</pre>
  </div>
</div>
<hr>
<div class="block">
  <p>Funkcji <code>bind</code> (lub <code>method</code>) będziemy potrzebować przy implementowaniu metody <code>step</code> naszego terrarium. Metoda ta musi przejrzeć wszystkie owady na siatce, spytać je o zamierzone działanie i wykonać to działanie. Może Cię kusić, aby przejrzeć siatkę za pomocą instrukcji <code>each</code> i zrobić, co trzeba z każdym napotkanym owadem. Ale wówczas, jeśli owad przemieści się na południe albo wschód, napotkamy go ponownie i znowu pozwolimy mu wykonać ruch.</p>
  <p>Dlatego najpierw zbierzemy wszystkie owady do tablicy, a potem je przetworzymy. Poniższa metoda zbiera owady lub inne byty mające metodę <code>act</code> i zapisuje je w obiektach zawierających dodatkowe informacje o ich bieżącym położeniu:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">listActingCreatures</span> = <span class="keyword">function</span>() {
    <span class="keyword">var</span> <span class="variabledef">found</span> = [];
    <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">point</span>, <span class="variabledef">value</span>) {
    <span class="keyword">if</span> (<span class="localvariable">value</span> != <span class="atom">undefined</span> &amp;&amp; <span class="localvariable">value</span>.<span class="property">act</span>)
    <span class="localvariable">found</span>.<span class="property">push</span>({<span class="property">object</span>: <span class="localvariable">value</span>, <span class="property">point</span>: <span class="localvariable">point</span>});
  });
    <span class="keyword">return</span> <span class="localvariable">found</span>;
};</pre>
</div>
<hr>
<div class="block">
  <div class="exercisenum">Ćwiczenie 8.5</div>
  <div class="exercise">
    <p>Prosząc owada, aby wykonał jakąś czynność musimy mu przekazać obiekt zawierający informacje o jego aktualnym otoczeniu. W obiekcie tym będą znajdować się własności o nazwach odpowiadających nazwom kierunków, o których była mowa wcześniej (<code>n</code>, <code>ne</code> itd.). Każda własność zawiera łańcuch składający się z jednego znaku, zwrócony przez <code>characterFromElement</code>, wskazujący co owad widzi w danym kierunku.</p>
    <p>Dodaj metodę <code>listSurroundings</code> do prototypu <code>Terrarium</code>. Metoda ta powinna przyjmować jeden argument będący punktem, w którym aktualnie znajduje się owad i zwracać obiekt z informacją o otoczeniu tego punktu. Gdy punkt znajduje się przy krawędzi siatki, kierunki wykraczające poza siatkę oznaczaj znakiem <code>#</code>, aby owad nie próbował tam się przemieścić.</p>
    <p>Podpowiedź: Nie wypisuj wszystkich kierunków, tylko zastosuj metodę <code>each</code> na słowniku <code>directions</code>.</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">listSurroundings</span> = <span class="keyword">function</span>(<span class="variabledef">center</span>) {
      <span class="keyword">var</span> <span class="variabledef">result</span> = {};
      <span class="keyword">var</span> <span class="variabledef">grid</span> = <span class="localvariable">this</span>.<span class="property">grid</span>;
      <span class="variable">directions</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">direction</span>) {
      <span class="keyword">var</span> <span class="variabledef">place</span> = <span class="localvariable">center</span>.<span class="property">add</span>(<span class="localvariable">direction</span>);
      <span class="keyword">if</span> (<span class="localvariable">grid</span>.<span class="property">isInside</span>(<span class="localvariable">place</span>))
      <span class="localvariable">result</span>[<span class="localvariable">name</span>] = <span class="variable">characterFromElement</span>(<span class="localvariable">grid</span>.<span class="property">valueAt</span>(<span class="localvariable">place</span>));
      <span class="keyword">else</span>
      <span class="localvariable">result</span>[<span class="localvariable">name</span>] = <span class="string">"#"</span>;
  });
      <span class="keyword">return</span> <span class="localvariable">result</span>;
};</pre>
    <p>Zwróć uwagę na użycie zmiennej <code>grid</code> w celu obejścia problemu z <code>this</code>.</p>
  </div>
</div>
<hr>
<div class="block">
  <p>Żadna z powyższych metod nie wchodzi w skład zewnętrznego interfejsu obiektu <code>Terrarium</code> — obie są wewnętrznymi szczegółami. W niektórych językach istnieje możliwość jawnego oznaczenia wybranych metod i własności jako „prywatnych” i spowodowanie, że próba ich użycia poza obiektem zakończy się błędem. W języku JavaScript nie jest to możliwe, przez co trzeba opisać interfejs za pomocą komentarzy. Czasami pomocne może być zastosowanie jakiegoś specyficznego nazewnictwa, aby odróżnić własności zewnętrzne od wewnętrznych. Można np. nazwom wszystkich metod wewnętrznych dodać przedrostek w postaci znaku podkreślenia („<code>_</code>”). Dzięki temu łatwiej będzie zauważyć wszystkie przypadkowe użycia własności nie należących do interfejsu obiektu.</p>
</div>
<hr>
<div class="block">
  <p>W następnej kolejności zajmiemy się kolejną metodą wewnętrzną, tą która pyta owada o czynność i ją wykonuje. Metoda ta przyjmuje jako argument obiekt z własnościami <code>object</code> i <code>point</code> zwrócony przez <code>listActingCreatures</code>. Na razie znana jest jej tylko czynność <code>move</code>:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">processCreature</span> = <span class="keyword">function</span>(<span class="variabledef">creature</span>) {
    <span class="keyword">var</span> <span class="variabledef">surroundings</span> = <span class="localvariable">this</span>.<span class="property">listSurroundings</span>(<span class="localvariable">creature</span>.<span class="property">point</span>);
    <span class="keyword">var</span> <span class="variabledef">action</span> = <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">act</span>(<span class="localvariable">surroundings</span>);
    <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">"move"</span> &amp;&amp; <span class="variable">directions</span>.<span class="property">contains</span>(<span class="localvariable">action</span>.<span class="property">direction</span>)) {
    <span class="keyword">var</span> <span class="variabledef">to</span> = <span class="localvariable">creature</span>.<span class="property">point</span>.<span class="property">add</span>(<span class="variable">directions</span>.<span class="property">lookup</span>(<span class="localvariable">action</span>.<span class="property">direction</span>));
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">isInside</span>(<span class="localvariable">to</span>) &amp;&amp; <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">valueAt</span>(<span class="localvariable">to</span>) == <span class="atom">undefined</span>)
    <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">moveValue</span>(<span class="localvariable">creature</span>.<span class="property">point</span>, <span class="localvariable">to</span>);
  }
    <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">"Nieobsługiwana czynność: "</span> + <span class="localvariable">action</span>.<span class="property">type</span>);
  }
};</pre>
  <p>Zauważ, że metoda ta sprawdza czy wybrany kierunek prowadzi do miejsca w obrębie siatki i czy to miejsce jest wolne. Jeśli nie jest, to je ignoruje. Dzięki temu owad może prosić o dowolną czynność. Jeśli jej wykonanie jest niemożliwe, to po prostu nic się nie dzieje. Jest to coś w rodzaju warstwy odizolowującej owady od terrarium, która pozwala nam trochę zaniedbać precyzję przy pisaniu metod <code>act</code> owadów ― np. owad <code>StupidBug</code> zawsze zmierza na południe, niezależnie od tego, czy na jego drodze stoją jakieś ściany.</p>
</div>
<hr>
<div class="block">
  <p>Te trzy wewnętrzne metody umożliwiły nam napisanie w końcu metody <code>step</code>, która wszystkim owadom daje szansę na wykonanie jakiejś czynności (dotyczy to wszystkich elementów mających metodę <code>act</code> ― moglibyśmy też taką metodę zdefiniować dla obiektu <code>wall</code>, gdybyśmy chcieli mieć ruchome ściany).</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">step</span> = <span class="keyword">function</span>() {
    <span class="variable">forEach</span>(<span class="localvariable">this</span>.<span class="property">listActingCreatures</span>(),
    <span class="variable">bind</span>(<span class="localvariable">this</span>.<span class="property">processCreature</span>, <span class="localvariable">this</span>));
};</pre>
  <p>Teraz możemy utworzyć terrarium, aby zobaczyć czy owady będą się w nim poruszać…</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">Terrarium</span>(<span class="variable">thePlan</span>);
    <span class="variable">print</span>(<span class="variable">terrarium</span>);
    <span class="variable">terrarium</span>.<span class="property">step</span>();
    <span class="variable">print</span>(<span class="variable">terrarium</span>);</pre>
</div>
<hr>
<div class="block">
  <p>Chwileczkę, jak to możliwe, że powyższe wywołania <code>print(terrarium)</code> powodują wyświetlenie wyniku naszej metody <code>toString</code>? Funkcja <code>print</code> zamienia swoje argumenty na łańcuchy za pomocą funkcji <code>String</code>. Obiekty zamienia się w łańcuchy wywołując ich metodę <code>toString</code>, a więc zdefiniowanie metody <code>toString</code> dla własnych typów obiektowych jest dobrym sposobem na sprawienie, aby były czytelne po wydrukowaniu.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Point</span>.<span class="property">prototype</span>.<span class="property">toString</span> = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="string">"("</span> + <span class="localvariable">this</span>.<span class="property">x</span> + <span class="string">","</span> + <span class="localvariable">this</span>.<span class="property">y</span> + <span class="string">")"</span>;
};
    <span class="variable">print</span>(<span class="keyword">new</span> <span class="variable">Point</span>(<span class="atom">5</span>, <span class="atom">5</span>));</pre>
</div>
<hr>
<div class="block">
  <p>Zgodnie z obietnicą obiekty <code>Terrarium</code> otrzymają także metody <code>start</code> i <code>stop</code> do uruchamiania i wyłączania symulacji. Do ich budowy użyjemy dwóch funkcji dostarczanych przez przeglądarkę: <code>setInterval</code> i <code>clearInterval</code>. Pierwsza z nich przyjmuje dwa argumenty. Pierwszy z nich określa kod (funkcję albo łańcuch zawierający kod JavaScript), który ma być przez tę metodę cyklicznie wywoływany. Natomiast drugi określa liczbę milisekund (1/1000 sekundy) między wywołaniami. Zwracana jest wartość, którą możne przekazać do metody <code>clearInterval</code>, aby zatrzymać wykonywanie.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">annoy</span> = <span class="variable">setInterval</span>(<span class="keyword">function</span>() {<span class="variable">print</span>(<span class="string">"Co?"</span>);}, <span class="atom">400</span>);</pre>
  <p>I…</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">clearInterval</span>(<span class="variable">annoy</span>);</pre>
  <p>Istnieją też podobne metody do jednorazowych czynności. Metoda <code>setTimeout</code> powoduje wykonanie funkcji lub łańcucha po upływie określonej liczby milisekund, a <code>clearTimeout</code> anuluje tę czynność.</p>
</div>
<hr>
<div class="block">
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">start</span> = <span class="keyword">function</span>() {
    <span class="keyword">if</span> (!<span class="localvariable">this</span>.<span class="property">running</span>)
    <span class="localvariable">this</span>.<span class="property">running</span> = <span class="variable">setInterval</span>(<span class="variable">bind</span>(<span class="localvariable">this</span>.<span class="property">step</span>, <span class="localvariable">this</span>), <span class="atom">500</span>);
};

    <span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">stop</span> = <span class="keyword">function</span>() {
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">running</span>) {
    <span class="variable">clearInterval</span>(<span class="localvariable">this</span>.<span class="property">running</span>);
    <span class="localvariable">this</span>.<span class="property">running</span> = <span class="atom">null</span>;
  }
};</pre>
</div>
<hr>
<div class="block">
  <p>Mamy już terrarium z kilkoma średnio bystrymi owadami i możemy je nawet uruchomić. Ale żeby zobaczyć, co się dzieje, musimy ciągle wywoływać funkcję <code>print(terrarium)</code>. Nie jest to praktyczne. Lepiej by było, gdyby terrarium było drukowane automatycznie. Ponadto lepszy efekt uzyskamy, jeśli zamiast drukować tysiące terrariów jedno pod drugim będziemy aktualizować jeden wydruk. Jeśli chodzi o drugi z opisanych problemów, to w tej książce dostępna jest pomocnicza funkcja o nazwie <code>inPlacePrinter</code>. Zwraca funkcję podobną do <code>print</code>, która zamiast dodawać wynik do aktualnego wydruku, zastępuje go.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">printHere</span> = <span class="variable">inPlacePrinter</span>();
    <span class="variable">printHere</span>(<span class="string">"Teraz widzisz."</span>);
    <span class="variable">setTimeout</span>(<span class="variable">partial</span>(<span class="variable">printHere</span>, <span class="string">"A teraz nie."</span>), <span class="atom">1000</span>);</pre>
  <p>Aby terrarium było ponownie drukowane po każdej zmianie, możemy zmodyfikować metodę <code>step</code>:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Terrarium</span>.<span class="property">prototype</span>.<span class="property">step</span> = <span class="keyword">function</span>() {
    <span class="variable">forEach</span>(<span class="localvariable">this</span>.<span class="property">listActingCreatures</span>(),
    <span class="variable">bind</span>(<span class="localvariable">this</span>.<span class="property">processCreature</span>, <span class="localvariable">this</span>));
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">onStep</span>)
    <span class="localvariable">this</span>.<span class="property">onStep</span>();
};</pre>
  <p>Do terrarium została dodana własność <code>onStep</code>, która będzie wywoływana w każdym kroku.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">Terrarium</span>(<span class="variable">thePlan</span>);
    <span class="variable">terrarium</span>.<span class="property">onStep</span> = <span class="variable">partial</span>(<span class="variable">inPlacePrinter</span>(), <span class="variable">terrarium</span>);
    <span class="variable">terrarium</span>.<span class="property">start</span>();</pre>
  <p>Zwróć uwagę na użycie funkcji <code>partial</code> ― tworzy miejscową drukarkę stosowaną do terrarium. Drukarka taka przyjmuje tylko jeden argument, a więc po jej częściowym zastosowaniu nie pozostają żadne argumenty i staje się funkcją zera argumentów. Dokładnie tego potrzeba nam dla własności <code>onStep</code>.</p>
  <p>Pamiętaj, że terrarium należy wyłączyć gdy nie jest już interesujące (co powinno nastąpić dosyć szybko), aby nie zużywało zasobów komputera:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">terrarium</span>.<span class="property">stop</span>();</pre>
</div>
<hr>
<div class="block">
  <p>Ale komu potrzebne jest terrarium z tylko jednym owadem i to głupim? Na pewno nie mnie. Fajnie by było, gdybyśmy mogli dodać jeszcze inne rodzaje owadów. Na szczęście jedyne, co w tym celu musimy zrobić, to uogólnić funkcję <code>elementFromCharacter</code>. Obecnie zawiera ona trzy przypadki, które są w niej bezpośrednio zakodowane:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">elementFromCharacter</span>(<span class="variabledef">character</span>) {
    <span class="keyword">if</span> (<span class="localvariable">character</span> == <span class="string">" "</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">character</span> == <span class="string">"#"</span>)
    <span class="keyword">return</span> <span class="variable">wall</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">character</span> == <span class="string">"o"</span>)
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable">StupidBug</span>();
}</pre>
  <p>Dwa pierwszy przypadki może pozostawić, ale trzeci jest o wiele za bardzo specyficzny. Lepszym rozwiązaniem byłoby zapisanie znaków i odpowiadających im konstruktorów owadów w słowniku i pobieranie ich stamtąd:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">creatureTypes</span> = <span class="keyword">new</span> <span class="variable">Dictionary</span>();
    <span class="variable">creatureTypes</span>.<span class="property">register</span> = <span class="keyword">function</span>(<span class="variabledef">constructor</span>) {
    <span class="localvariable">this</span>.<span class="property">store</span>(<span class="localvariable">constructor</span>.<span class="property">prototype</span>.<span class="property">character</span>, <span class="localvariable">constructor</span>);
};

    <span class="keyword">function</span> <span class="variable">elementFromCharacter</span>(<span class="variabledef">character</span>) {
    <span class="keyword">if</span> (<span class="localvariable">character</span> == <span class="string">" "</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">character</span> == <span class="string">"#"</span>)
    <span class="keyword">return</span> <span class="variable">wall</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">creatureTypes</span>.<span class="property">contains</span>(<span class="localvariable">character</span>))
    <span class="keyword">return</span> <span class="keyword">new</span> (<span class="variable">creatureTypes</span>.<span class="property">lookup</span>(<span class="localvariable">character</span>))();
    <span class="keyword">else</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">"Nieznany znak: "</span> + <span class="localvariable">character</span>);
}</pre>
  <p>Zwróć uwagę na sposób dodania metody <code>register</code> do obiektu <code>creatureTypes</code> ― to, że jest to obiekt słownikowy nie znaczy, że nie może on obsługiwać dodatkowej metody. Metoda ta znajduje znak związany z konstruktorem i zapisuje go w słowniku. Powinna być wywoływana wyłącznie na konstruktorach, których prototypy zawierają własność <code>character</code>.</p>
  <p>Teraz metoda <code>elementFromCharacter</code> szuka znaku podanego jej w <code>creatureTypes</code> i zgłasza wyjątek jeśli otrzyma nieznany znak.</p>
</div>
<hr>
<div class="block">
  <p>Poniżej znajduje się definicja nowego typu owada i wywołanie rejestrujące jego znak w <code>creatureTypes</code>:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">BouncingBug</span>() {
    <span class="localvariable">this</span>.<span class="property">direction</span> = <span class="string">"ne"</span>;
}
    <span class="variable">BouncingBug</span>.<span class="property">prototype</span>.<span class="property">act</span> = <span class="keyword">function</span>(<span class="variabledef">surroundings</span>) {
    <span class="keyword">if</span> (<span class="localvariable">surroundings</span>[<span class="localvariable">this</span>.<span class="property">direction</span>] != <span class="string">" "</span>)
    <span class="localvariable">this</span>.<span class="property">direction</span> = (<span class="localvariable">this</span>.<span class="property">direction</span> == <span class="string">"ne"</span> ? <span class="string">"sw"</span> : <span class="string">"ne"</span>);
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"move"</span>, <span class="property">direction</span>: <span class="localvariable">this</span>.<span class="property">direction</span>};
};
    <span class="variable">BouncingBug</span>.<span class="property">prototype</span>.<span class="property">character</span> = <span class="string">"%"</span>;

    <span class="variable">creatureTypes</span>.<span class="property">register</span>(<span class="variable">BouncingBug</span>);</pre>
  <p>Rozumiesz jak to działa?</p>
</div>
<hr>
<div class="block">
  <div class="exercisenum" id="exercise6">Ćwiczenie 8.6</div>
  <div class="exercise">
    <p>Utwórz typ owada o nazwie <code>DrunkBug</code>, który w każdej kolejce próbuje wykonać ruch w losowym kierunku nie zważając na ściany. Przypomnij sobie sztuczkę z <code>Math.random</code> z <a href="/kursy/javascript/wszystko-jasne/r7-wyszukiwanie">rozdziału 7</a>.</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <p>Aby wybrać losowy kierunek, potrzebna nam jest tablica nazw kierunków. Oczywiście moglibyśmy po prostu napisać <code>["n", "ne", ...]</code>, ale to oznaczałoby duplikowanie informacji, a powielanie danych mnie złości. Moglibyśmy też do budowy tej tablicy użyć instrukcji <code>each</code> w obiekcie <code>directions</code>, co byłoby już lepszym rozwiązaniem.</p>
    <p>Jednak w tym przypadku jest możliwość zastosowania uogólnienia. Możliwość utworzenia listy nazw własności znajdujących się w słowniku wydaje się bardzo przydatna, a więc dodamy takie narzędzie do prototypu <code>Dictionary</code>.</p>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Dictionary</span>.<span class="property">prototype</span>.<span class="property">names</span> = <span class="keyword">function</span>() {
      <span class="keyword">var</span> <span class="variabledef">names</span> = [];
      <span class="localvariable">this</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">value</span>) {<span class="localvariable">names</span>.<span class="property">push</span>(<span class="localvariable">name</span>);});
      <span class="keyword">return</span> <span class="localvariable">names</span>;
};

      <span class="variable">show</span>(<span class="variable">directions</span>.<span class="property">names</span>());</pre>
    <p>Neurotyk od razu dodałby jeszcze dla równowagi metodę <code>values</code> zwracającą listę wartości zapisanych w słowniku. Myślę jednak, że to może poczekać, aż <a href="http://www.c2.com/cgi/wiki?YouArentGonnaNeedIt">będzie potrzebne</a>.</p>
    <p>Oto sposób pobrania losowego elementu z tablicy:</p>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">randomElement</span>(<span class="variabledef">array</span>) {
      <span class="keyword">if</span> (<span class="localvariable">array</span>.<span class="property">length</span> == <span class="atom">0</span>)
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">"Tablica jest pusta."</span>);
      <span class="keyword">return</span> <span class="localvariable">array</span>[<span class="variable">Math</span>.<span class="property">floor</span>(<span class="variable">Math</span>.<span class="property">random</span>() * <span class="localvariable">array</span>.<span class="property">length</span>)];
}

      <span class="variable">show</span>(<span class="variable">randomElement</span>([<span class="string">"heads"</span>, <span class="string">"tails"</span>]));</pre>
    <p>A to jest owad we własnej osobie:</p>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">DrunkBug</span>() {};
      <span class="variable">DrunkBug</span>.<span class="property">prototype</span>.<span class="property">act</span> = <span class="keyword">function</span>(<span class="variabledef">surroundings</span>) {
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"move"</span>,
      <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="variable">directions</span>.<span class="property">names</span>())};
};
      <span class="variable">DrunkBug</span>.<span class="property">prototype</span>.<span class="property">character</span> = <span class="string">"~"</span>;

      <span class="variable">creatureTypes</span>.<span class="property">register</span>(<span class="variable">DrunkBug</span>);</pre>
  </div>
</div>
<hr>
<div class="block">
  <p>Przetestujmy nasze nowe owady:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">newPlan</span> =
  [<span class="string">"############################"</span>,
    <span class="string">"#                      #####"</span>,
    <span class="string">"#    ##                 ####"</span>,
    <span class="string">"#   ####     ~ ~          ##"</span>,
    <span class="string">"#    ##       ~            #"</span>,
    <span class="string">"#                          #"</span>,
    <span class="string">"#                ###       #"</span>,
    <span class="string">"#               #####      #"</span>,
    <span class="string">"#                ###       #"</span>,
    <span class="string">"# %        ###        %    #"</span>,
    <span class="string">"#        #######           #"</span>,
    <span class="string">"############################"</span>];

    <span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">Terrarium</span>(<span class="variable">newPlan</span>);
    <span class="variable">terrarium</span>.<span class="property">onStep</span> = <span class="variable">partial</span>(<span class="variable">inPlacePrinter</span>(), <span class="variable">terrarium</span>);
    <span class="variable">terrarium</span>.<span class="property">start</span>();</pre>
  <p>Widzisz, jak teraz pijane owady obijają się po całej scenie? Czysta komedia. Gdy nacieszysz już oko tym fascynującym przedstawieniem, wyłącz je:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">terrarium</span>.<span class="property">stop</span>();</pre>
</div>
<hr>
<div class="block">
  <p>Mamy już dwa rodzaje obiektów zawierających metodę <code>act</code> i własność <code>character</code>. Dzięki temu, że mają wspólne te cechy, terrarium może z nimi postępować w taki sam sposób. A to oznacza, że możemy utworzyć dowolną liczbę owadów nie zmieniając niczego w kodzie terrarium. Technika ta to <strong>polimorfizm</strong>. Jest to chyba najpotężniejsze narzędzie programowania obiektowego.</p>
  <p>Mówiąc najprościej w polimorfizmie chodzi o to, że gdy zostanie napisany moduł kodu przystosowany do współpracy z obiektami mającymi określony interfejs, to można do niego podłączyć obiekt dowolnego typu, który ten interfejs obsługuje. Widzieliśmy już proste przykłady zastosowania tego, np. metodę <code>toString</code> obiektów. Wszystkie obiekty mające zdefiniowaną w sensowny sposób metodę <code>toString</code> można przekazać do funkcji <code>print</code> oraz innych funkcji konwertujących wartości na łańcuchy i zostanie utworzony prawidłowy łańcuch bez względu na to, jak ich metoda <code>toString</code> go zbuduje.</p>
  <p>Analogicznie funkcja <code>forEach</code> działa zarówno na prawdziwych tablicach, jak i pseudotablicach znajdujących się w zmiennej <code>arguments</code>, ponieważ potrzebna jest jej tylko własność <code>length</code> oraz własności o nazwach <code>0</code>, <code>1</code> itd. elementów tablicy.</p>
</div>
<hr>
<div class="block">
  <p>Aby trochę urozmaicić życie w terrarium, dodamy do niego pojęcia pożywienia i rozmnażania. Każdemu stworzeniu w terrarium dodamy nową własność o nazwie <code>energy</code>, której wartość będzie się zmniejszała w wyniku wykonywanych czynności i zwiększała w wyniku zjadania pożywienia. Gdy żyjątko będzie miało wystarczająco dużo energii, będzie mogło się rozmnożyć<a class="footref" href="#footnote2">2</a>, czyli wygenerować nowe stworzenie tego samego gatunku.</p>
  <p>Jeśli w terrarium będą tylko owady marnujące energię na poruszanie się i zjadanie się nawzajem, szybko pogrąży się ono w entropii, skończy się energia i zostanie tylko martwa pustynia. Aby temu zapobiec (a przynajmniej, żeby nie nastąpiło to zbyt szybko), dodamy do terrarium porosty. Porosty nie ruszają się, a jedynie gromadzą energię dzięki fotosyntezie i rozmnażają się.</p>
  <p>Aby to działało, potrzebujemy terrarium z inną metodą <code>processCreature</code>. Moglibyśmy zmienić metodę prototypu <code>Terrarium</code>, ale zbytnio przywiązaliśmy się do symulacji pijanych owadów i nie chcielibyśmy niszczyć starego terrarium.</p>
  <p>W związku z tym możemy utworzyć nowy konstruktor, np. o nazwie <code>LifeLikeTerrarium</code>, którego prototyp będzie oparty na prototypie <code>Terrarium</code>, ale który będzie miał inną metodę <code>processCreature</code>.</p>
</div>
<hr>
<div class="block">
  <p>Pomysł ten można zrealizować na kilka sposobów. Można przejrzeć własności prototypu <code>Terrarium.prototype</code> i dodać je jedna po drugiej do prototypu <code>LifeLikeTerrarium.prototype</code>. Wykonanie tego jest łatwe i w niektórych sytuacjach jest to najlepsze rozwiązanie, ale w tym przypadku jest lepszy sposób. Jeśli stary obiekt prototypowy uczynimy prototypem nowego obiektu prototypowego (możliwe, że będziesz musiał kilka razy przeczytać tę część zdania), to ten nowy obiekt automatycznie otrzyma wszystkie własności starego.</p>
  <p>Niestety w języku JavaScript nie da się w łatwy sposób utworzyć obiektu, którego prototypem jest wybrany inny obiekt. Można jednak napisać funkcję, która to zrobi. Trzeba tylko zastosować następującą sztuczkę:</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">clone</span>(<span class="variabledef">object</span>) {
    <span class="keyword">function</span> <span class="variabledef">OneShotConstructor</span>(){}
    <span class="localvariable">OneShotConstructor</span>.<span class="property">prototype</span> = <span class="localvariable">object</span>;
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="localvariable">OneShotConstructor</span>();
}</pre>
  <p>W funkcji tej użyty jest pusty jednorazowy konstruktor, którego prototypem jest podany obiekt. Jeśli do tego konstruktora zastosuje się operator <code>new</code>, utworzy on nowy obiekt na bazie podanego obiektu.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">LifeLikeTerrarium</span>(<span class="variabledef">plan</span>) {
    <span class="variable">Terrarium</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">plan</span>);
}
    <span class="variable">LifeLikeTerrarium</span>.<span class="property">prototype</span> = <span class="variable">clone</span>(<span class="variable">Terrarium</span>.<span class="property">prototype</span>);
    <span class="variable">LifeLikeTerrarium</span>.<span class="property">prototype</span>.<span class="property">constructor</span> = <span class="variable">LifeLikeTerrarium</span>;</pre>
  <p>Nowy konstruktor nie musi robić czegokolwiek innego niż stary, a więc tylko wywołuje stary konstruktor na obiekcie <code>this</code>. Musimy też odtworzyć własność <code>constructor</code> w nowym prototypie, bo jeśli tego nie zrobimy, będzie „twierdził”, że jego konstruktorem jest <code>Terrarium</code> (to oczywiście sprawiałoby problem, gdybyśmy używali tej własności, a tutaj tego nie robimy).</p>
</div>
<hr>
<div class="block">
  <p>Teraz można wymienić niektóre metody obiektu <code>LifeLikeTerrarium</code> albo dodać nowe. Utworzyliśmy nowy typ obiektu na bazie innego, dzięki czemu uniknęliśmy przepisywania wszystkich metod, które w <code>Terrarium</code> i <code>LifeLikeTerrarium</code> są takie same. Technika ta nazywa się <strong>dziedziczenie</strong>. Nowy typ dziedziczy własności po starym typie. W większości przypadków nowy typ obsługuje także interfejs starego typu, ale może mieć dodatkowo inne metody nie obsługiwane przez stary typ. Dzięki temu obiektów nowego typu można używać wszędzie tam, gdzie można używać obiektów starego typu. To się nazywa polimorfizm.</p>
  <p>W większości „typowo” obiektowych języków programowania dziedziczenie jest jednym z fundamentów i korzystanie z niego jest bardzo łatwe. W JavaScripcie jednak nie ma specjalnego mechanizmu, który by to umożliwiał. Z tego też powodu programiści używający JavaScriptu opracowali wiele własnych technik realizacji dziedziczenia. Niestety każda z nich ma jakieś wady. Z drugiej strony jest ich tak dużo, że zawsze da się znaleźć odpowiednią, a ponadto można stosować sztuczki, które w innych językach są niemożliwe.</p>
  <p>Na zakończenie rozdziału pokażę Ci kilka innych technik realizacji dziedziczenia oraz opiszę ich wady.</p>
</div>
<hr>
<div class="block">
  <p>Poniżej znajduje się kod nowej metody o nazwie <code>processCreature</code>. Metoda ta jest dość duża.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">LifeLikeTerrarium</span>.<span class="property">prototype</span>.<span class="property">processCreature</span> = <span class="keyword">function</span>(<span class="variabledef">creature</span>) {
    <span class="keyword">var</span> <span class="variabledef">surroundings</span> = <span class="localvariable">this</span>.<span class="property">listSurroundings</span>(<span class="localvariable">creature</span>.<span class="property">point</span>);
    <span class="keyword">var</span> <span class="variabledef">action</span> = <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">act</span>(<span class="localvariable">surroundings</span>);

    <span class="keyword">var</span> <span class="variabledef">target</span> = <span class="atom">undefined</span>;
    <span class="keyword">var</span> <span class="variabledef">valueAtTarget</span> = <span class="atom">undefined</span>;
    <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">direction</span> &amp;&amp; <span class="variable">directions</span>.<span class="property">contains</span>(<span class="localvariable">action</span>.<span class="property">direction</span>)) {
    <span class="keyword">var</span> <span class="variabledef">direction</span> = <span class="variable">directions</span>.<span class="property">lookup</span>(<span class="localvariable">action</span>.<span class="property">direction</span>);
    <span class="keyword">var</span> <span class="variabledef">maybe</span> = <span class="localvariable">creature</span>.<span class="property">point</span>.<span class="property">add</span>(<span class="localvariable">direction</span>);
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">isInside</span>(<span class="localvariable">maybe</span>)) {
    <span class="localvariable">target</span> = <span class="localvariable">maybe</span>;
    <span class="localvariable">valueAtTarget</span> = <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">valueAt</span>(<span class="localvariable">target</span>);
    }
  }

    <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">"move"</span>) {
    <span class="keyword">if</span> (<span class="localvariable">target</span> &amp;&amp; !<span class="localvariable">valueAtTarget</span>) {
    <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">moveValue</span>(<span class="localvariable">creature</span>.<span class="property">point</span>, <span class="localvariable">target</span>);
    <span class="localvariable">creature</span>.<span class="property">point</span> = <span class="localvariable">target</span>;
    <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energy</span> -= <span class="atom">1</span>;
    }
  }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">"eat"</span>) {
    <span class="keyword">if</span> (<span class="localvariable">valueAtTarget</span> &amp;&amp; <span class="localvariable">valueAtTarget</span>.<span class="property">energy</span>) {
    <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">setValueAt</span>(<span class="localvariable">target</span>, <span class="atom">undefined</span>);
    <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energy</span> += <span class="localvariable">valueAtTarget</span>.<span class="property">energy</span>;
    }
  }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">"photosynthese"</span>) {
    <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energy</span> += <span class="atom">1</span>;
  }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">"reproduce"</span>) {
    <span class="keyword">if</span> (<span class="localvariable">target</span> &amp;&amp; !<span class="localvariable">valueAtTarget</span>) {
    <span class="keyword">var</span> <span class="variabledef">species</span> = <span class="variable">characterFromElement</span>(<span class="localvariable">creature</span>.<span class="property">object</span>);
    <span class="keyword">var</span> <span class="variabledef">baby</span> = <span class="variable">elementFromCharacter</span>(<span class="localvariable">species</span>);
    <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energy</span> -= <span class="localvariable">baby</span>.<span class="property">energy</span> * <span class="atom">2</span>;
    <span class="keyword">if</span> (<span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energy</span> &gt; <span class="atom">0</span>)
    <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">setValueAt</span>(<span class="localvariable">target</span>, <span class="localvariable">baby</span>);
    }
  }
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">action</span>.<span class="property">type</span> == <span class="string">"wait"</span>) {
    <span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energy</span> -= <span class="atom">0.2</span>;
  }
    <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">"Nieobsługiwana czynność: "</span> + <span class="localvariable">action</span>.<span class="property">type</span>);
  }

    <span class="keyword">if</span> (<span class="localvariable">creature</span>.<span class="property">object</span>.<span class="property">energy</span> &lt;= <span class="atom">0</span>)
    <span class="localvariable">this</span>.<span class="property">grid</span>.<span class="property">setValueAt</span>(<span class="localvariable">creature</span>.<span class="property">point</span>, <span class="atom">undefined</span>);
};</pre>
  <p>Funkcja nadal rozpoczyna działanie od spytania stworzenia, co chce zrobić. Jeśli wybrana czynność ma własność <code>direction</code> (kierunek), oblicza który punkt na siatce ten kierunek wskazuje i jaka wartość aktualnie się w nim znajduje. Informacja ta jest potrzebna trzem z pięcie obsługiwanych akcji i gdyby każda z nich obliczenia wykonywała osobno, kod byłby jeszcze bardziej niezgrabny. Jeśli nie ma własności <code>direction</code> albo jest niepoprawna, zmienne <code>target</code> i <code>valueAtTarget</code> pozostają niezdefiniowane.</p>
  <p>Następnie funkcja przechodzi przez akcje. Niektóre akcje przed wykonaniem wymagają dodatkowych testów, które są realizowane w osobnej instrukcji <code>if</code>, dzięki czemu jeśli jakieś stworzenie spróbuje np. przejść przez ścianę nie generujemy wyjątku <code>"Nieobsługiwana czynność"</code>.</p>
  <p>Zwróć uwagę, że w akcji <code>reproduce</code> stworzenie będące rodzicem traci dwa razy tyle energii, co otrzymuje nowonarodzone stworzenie (rodzenie dzieci nie jest łatwe) i potomek pojawia się na siatce tylko, jeśli rodzic ma wystarczająco dużo energii.</p>
  <p>Gdy czynność zostanie wykonana sprawdzamy, czy stworzeniu nie wyczerpała się energia. Jeśli tak, stworzenie umiera i usuwamy je.</p>
</div>
<hr>
<div class="block">
  <p>Porosty nie są skomplikowanymi organizmami. Na planszy będą reprezentowane przez znak <code>*</code>. Upewnij się, że masz zdefiniowaną funkcję <code>randomElement</code> z <a href="#exercise6">ćwiczenia 8.6</a>, ponieważ będzie nam tu potrzebna.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">Lichen</span>() {
    <span class="localvariable">this</span>.<span class="property">energy</span> = <span class="atom">5</span>;
}
    <span class="variable">Lichen</span>.<span class="property">prototype</span>.<span class="property">act</span> = <span class="keyword">function</span>(<span class="variabledef">surroundings</span>) {
    <span class="keyword">var</span> <span class="variabledef">emptySpace</span> = <span class="variable">findDirections</span>(<span class="localvariable">surroundings</span>, <span class="string">" "</span>);
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energy</span> &gt;= <span class="atom">13</span> &amp;&amp; <span class="localvariable">emptySpace</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"reproduce"</span>, <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">emptySpace</span>)};
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energy</span> &lt; <span class="atom">20</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"photosynthese"</span>};
    <span class="keyword">else</span>
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"wait"</span>};
};
    <span class="variable">Lichen</span>.<span class="property">prototype</span>.<span class="property">character</span> = <span class="string">"*"</span>;

    <span class="variable">creatureTypes</span>.<span class="property">register</span>(<span class="variable">Lichen</span>);

    <span class="keyword">function</span> <span class="variable">findDirections</span>(<span class="variabledef">surroundings</span>, <span class="variabledef">wanted</span>) {
    <span class="keyword">var</span> <span class="variabledef">found</span> = [];
    <span class="variable">directions</span>.<span class="property">each</span>(<span class="keyword">function</span>(<span class="variabledef">name</span>) {
    <span class="keyword">if</span> (<span class="localvariable">surroundings</span>[<span class="localvariable">name</span>] == <span class="localvariable">wanted</span>)
    <span class="localvariable">found</span>.<span class="property">push</span>(<span class="localvariable">name</span>);
  });
    <span class="keyword">return</span> <span class="localvariable">found</span>;
}</pre>
  <p>Maksymalny poziom energii porostów wynosi 20. Gdyby mogły rosnąć większe, to tworzyłyby <em>gigantyczne</em> skupiska i nie byłoby miejsca na rozmnażanie.</p>
</div>
<hr>
<div class="block">
  <div class="exercisenum">Ćwiczenie 8.7</div>
  <div class="exercise">
    <p>Utwórz stworzenie <code>LichenEater</code> (zjadacz porostów). Początkowo niech ma <code>10</code> jednostek energii i niech zachowuje się następująco:</p>
    <ul>
      <li>gdy ma nie mniej niż 30 jednostek energii i jest wystarczająco dużo miejsca, rozmnaża się.</li>
      <li>W przeciwnym przypadku, jeśli w pobliżu są jakieś porosty, niech je losowo zjada.</li>
      <li>Jeśli nie ma porostów w pobliżu, ale jest puste miejsce, niech się przemieszcza w losowo wybranym kierunku.</li>
      <li>Jeśli nie ma wolnych miejsc, niech czeka.</li>
    </ul>
    <p>Do sprawdzania otoczenia i wybierania kierunku użyj metod <code>findDirections</code> i <code>randomElement</code>. Stworom tym przypisz literę <code>c</code> na planszy (jak pac-man).</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">LichenEater</span>() {
      <span class="localvariable">this</span>.<span class="property">energy</span> = <span class="atom">10</span>;
}
      <span class="variable">LichenEater</span>.<span class="property">prototype</span>.<span class="property">act</span> = <span class="keyword">function</span>(<span class="variabledef">surroundings</span>) {
      <span class="keyword">var</span> <span class="variabledef">emptySpace</span> = <span class="variable">findDirections</span>(<span class="localvariable">surroundings</span>, <span class="string">" "</span>);
      <span class="keyword">var</span> <span class="variabledef">lichen</span> = <span class="variable">findDirections</span>(<span class="localvariable">surroundings</span>, <span class="string">"*"</span>);

      <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energy</span> &gt;= <span class="atom">30</span> &amp;&amp; <span class="localvariable">emptySpace</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"reproduce"</span>, <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">emptySpace</span>)};
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">lichen</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"eat"</span>, <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">lichen</span>)};
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">emptySpace</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"move"</span>, <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">emptySpace</span>)};
      <span class="keyword">else</span>
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"wait"</span>};
};
      <span class="variable">LichenEater</span>.<span class="property">prototype</span>.<span class="property">character</span> = <span class="string">"c"</span>;

      <span class="variable">creatureTypes</span>.<span class="property">register</span>(<span class="variable">LichenEater</span>);</pre>
  </div>
</div>
<hr>
<div class="block">
  <p>Wypróbuj to.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">lichenPlan</span> =
  [<span class="string">"############################"</span>,
    <span class="string">"#                     ######"</span>,
    <span class="string">"#    ***                **##"</span>,
    <span class="string">"#   *##**         **  c  *##"</span>,
    <span class="string">"#    ***     c    ##**    *#"</span>,
    <span class="string">"#       c         ##***   *#"</span>,
    <span class="string">"#                 ##**    *#"</span>,
    <span class="string">"#   c       #*            *#"</span>,
    <span class="string">"#*          #**       c   *#"</span>,
    <span class="string">"#***        ##**    c    **#"</span>,
    <span class="string">"#*****     ###***       *###"</span>,
    <span class="string">"############################"</span>];

    <span class="keyword">var</span> <span class="variable">terrarium</span> = <span class="keyword">new</span> <span class="variable">LifeLikeTerrarium</span>(<span class="variable">lichenPlan</span>);
    <span class="variable">terrarium</span>.<span class="property">onStep</span> = <span class="variable">partial</span>(<span class="variable">inPlacePrinter</span>(), <span class="variable">terrarium</span>);
    <span class="variable">terrarium</span>.<span class="property">start</span>();</pre>
  <p>Najprawdopodobniej najpierw porosty szybko rozrosną się i zajmą dużą część terrarium, po czym duża ilość pożywienia sprawi, że zaczną mnożyć się w dużych ilościach zjadacze porostów, które wytępią porosty i przy okazji samych siebie. Cóż, taka już jest natura.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">terrarium</span>.<span class="property">stop</span>();</pre>
</div>
<hr>
<div class="block">
  <p>Śmierć wszystkich mieszkańców naszego terrarium w ciągu kilku minut nie jest dla nas miła. Aby temu zapobiec, musimy nauczyć zjadaczy porostów długofalowego zarządzania pożywieniem. Jeśli będą zjadać porosty tylko wtedy, gdy w pobliżu widzą przynajmniej dwa krzaki (bez względu na to jak są głodne), to nigdy nie wytępią wszystkich porostów. Do tego potrzebna jest dyscyplina, ale w ten sposób powstanie biotop, który nie będzie niszczył samego siebie. Poniżej znajduje się nowy kod metody <code>act</code> ― jedyna zmiana polega na tym, że jedzenie jest wykonywane tylko wtedy, gdy własność <code>lichen.length</code> ma wartość nie mniejszą od dwóch.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">LichenEater</span>.<span class="property">prototype</span>.<span class="property">act</span> = <span class="keyword">function</span>(<span class="variabledef">surroundings</span>) {
    <span class="keyword">var</span> <span class="variabledef">emptySpace</span> = <span class="variable">findDirections</span>(<span class="localvariable">surroundings</span>, <span class="string">" "</span>);
    <span class="keyword">var</span> <span class="variabledef">lichen</span> = <span class="variable">findDirections</span>(<span class="localvariable">surroundings</span>, <span class="string">"*"</span>);

    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energy</span> &gt;= <span class="atom">30</span> &amp;&amp; <span class="localvariable">emptySpace</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"reproduce"</span>, <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">emptySpace</span>)};
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">lichen</span>.<span class="property">length</span> &gt; <span class="atom">1</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"eat"</span>, <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">lichen</span>)};
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">emptySpace</span>.<span class="property">length</span> &gt; <span class="atom">0</span>)
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"move"</span>, <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">emptySpace</span>)};
    <span class="keyword">else</span>
    <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"wait"</span>};
};</pre>
  <p>Uruchom ponownie terrarium <code>lichenPlan</code> i zobacz, co się dzieje. Po pewnym czasie zjadacze porostów prawdopodobnie wyginą, ponieważ podczas masowego głodu będą poruszać się bezcelowo w przód i w tył, zamiast znajdować porosty znajdujące się tuż obok.</p>
</div>
<hr>
<div class="block">
  <div class="exercisenum">Ćwiczenie 8.8</div>
  <div class="exercise">
    <p>Zmodyfikuj obiekt <code>LichenEater</code>, aby miał większą szansę na przetrwanie. Nie oszukuj, tzn. <code>this.energy += 100</code> jest niedozwolone. Jeśli od nowa napiszesz konstruktor, nie zapomnij go zarejestrować w słowniku <code>creatureTypes</code> albo terrarium nadal będzie używać starego.</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <p>Jednym z rozwiązań może być rezygnacja z losowego wybierania kierunków ruchu. gdy kierunki są wybierane losowo, stwory często poruszają się w tę i z powrotem ostatecznie nigdzie nie docierając. Jeśli stworzenie będzie pamiętać kierunek ostatniego ruchu i preferować jego kontynuację, zmarnuje mniej czasu i szybciej dotrze do pożywienia.</p>
    <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">CleverLichenEater</span>() {
      <span class="localvariable">this</span>.<span class="property">energy</span> = <span class="atom">10</span>;
      <span class="localvariable">this</span>.<span class="property">direction</span> = <span class="string">"ne"</span>;
}
      <span class="variable">CleverLichenEater</span>.<span class="property">prototype</span>.<span class="property">act</span> = <span class="keyword">function</span>(<span class="variabledef">surroundings</span>) {
      <span class="keyword">var</span> <span class="variabledef">emptySpace</span> = <span class="variable">findDirections</span>(<span class="localvariable">surroundings</span>, <span class="string">" "</span>);
      <span class="keyword">var</span> <span class="variabledef">lichen</span> = <span class="variable">findDirections</span>(<span class="localvariable">surroundings</span>, <span class="string">"*"</span>);

      <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">energy</span> &gt;= <span class="atom">30</span> &amp;&amp; <span class="localvariable">emptySpace</span>.<span class="property">length</span> &gt; <span class="atom">0</span>) {
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"reproduce"</span>,
      <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">emptySpace</span>)};
  }
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">lichen</span>.<span class="property">length</span> &gt; <span class="atom">1</span>) {
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"eat"</span>,
      <span class="property">direction</span>: <span class="variable">randomElement</span>(<span class="localvariable">lichen</span>)};
  }
      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="localvariable">emptySpace</span>.<span class="property">length</span> &gt; <span class="atom">0</span>) {
      <span class="keyword">if</span> (<span class="localvariable">surroundings</span>[<span class="localvariable">this</span>.<span class="property">direction</span>] != <span class="string">" "</span>)
      <span class="localvariable">this</span>.<span class="property">direction</span> = <span class="variable">randomElement</span>(<span class="localvariable">emptySpace</span>);
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"move"</span>,
      <span class="property">direction</span>: <span class="localvariable">this</span>.<span class="property">direction</span>};
  }
      <span class="keyword">else</span> {
      <span class="keyword">return</span> {<span class="property">type</span>: <span class="string">"wait"</span>};
  }
};
      <span class="variable">CleverLichenEater</span>.<span class="property">prototype</span>.<span class="property">character</span> = <span class="string">"c"</span>;

      <span class="variable">creatureTypes</span>.<span class="property">register</span>(<span class="variable">CleverLichenEater</span>);</pre>
    <p>Wypróbuj to na poprzedniej planszy terrarium.</p>
  </div>
</div>
<hr>
<div class="block">
  <div class="exercisenum">Ćwiczenie 8.9</div>
  <div class="exercise">
    <p>Łańcuch pokarmowy zawierający tylko jedno ogniwo to wciąż uboga opcja. Czy potrafisz napisać nowego stwora, <code>LichenEaterEater</code> (znak <code>@</code>), który aby żyć musi zjadać zjadaczy porostów? Spróbuj tak go dopasować do ekosystemu, aby zbyt szybko nie wymarł. Dodaj kilka takich stworzeń do tablicy <code>lichenPlan</code> i wypróbuj je.</p>
  </div>
  <div class="toggle">[pokaż rozwiązanie]</div><div class="solution" style="display: none;"><div class="solutionarrow" title="Ukryj rozwiązanie">×</div>
    <p>Rozwiązanie tego problemu musisz znaleźć sam. Mnie nie udało się znaleźć dobrego sposobu na to, aby zapobiec wyginięciu tych stworzeń natychmiast albo zaraz po wytępieniu wszystkich zjadaczy porostów. Sztuczka ze zjadaniem osobników tylko wtedy, gdy dwa z nich znajdują się obok siebie tutaj nie działa, ponieważ osobniki te się ruszają i trudno napotkać je, gdy są obok siebie. Obiecującym rozwiązaniem jest danie zjadaczom zjadaczy dużo energii, dzięki której mogą przetrwać czas, gdy jest mało zjadaczy porostów oraz powolne rozmnażanie, dzięki czemu zasoby pożywienia nie są zbyt szybko zużywane.</p>
    <p>Życiem porostów i zjadaczy rządzi pewien cykl — raz jest dużo porostów, co powoduje, że rodzi się dużo zjadaczy, co z kolei powoduje, że robi się mało porostów, z którego to powodu zjadacze zaczynają umierać z głodu, co sprawia że porosty znowu się rozrastają itd. Można też spróbować hibernacji zjadaczy zjadaczy porostów (przy użyciu akcji <code>wait</code>) na pewien czas, gdy nie uda im się znaleźć nic do jedzenia przez kilka kolejek. Dobre efekty może przynieść wybudzanie stworów z hibernacji po odpowiedniej liczbie kolejek albo gdy wyczują w pobliżu jedzenie.</p>
  </div>
</div>
<hr>
<div class="block">
  <p>Na tym zakończymy pracę nad naszym terrarium. W dalszej części rozdziału bardziej dogłębnie zajmiemy się kwestią dziedziczenia i związanymi z tym problemami w JavaScripcie.</p>
</div>
<hr>
<div class="block">
  <p>Zaczniemy od odrobiny teorii. Studenci uczący się programowania obiektowego często dyskutują na temat prawidłowych i nieprawidłowych sposobów wykorzystania technik dziedziczenia. Dlatego ważne jest, aby zdawać sobie sprawę, że dziedziczenie to tak naprawdę tylko sztuczka pozwalająca leniwym<a class="footref" href="#footnote3">3</a> programistom uniknąć pisania części kodu. W związku z tym wszelkie dyskusje dotyczące poprawności stosowania dziedziczenia sprowadzają się do rozstrzygnięcia, czy otrzymany kod działa poprawnie i nie zawiera niepotrzebnych powtórzeń. Z drugiej strony zasady, o których toczone są wspomniane dyskusje mogą być dobrym wstępem do dziedziczenia.</p>
  <p>Dziedziczenie to technika tworzenia nowych typów obiektów, tzw. podtypów, na bazie istniejących typów, tzw. nadtypów. Podtyp dziedziczy po nadtypie wszystkie własności i metody, a następnie może je modyfikować i ewentualnie dodawać nowe. Dziedziczenie najlepiej jest stosować wtedy, gdy obiekt, którego modelem jest podtyp może <em>być</em> określony, jako obiekt nadtypu.</p>
  <p>Na przykład typ <code>Fortepian</code> może być podtypem typu <code>Instrument</code>, ponieważ fortepian <em>jest</em> instrumentem. Ponieważ fortepian ma szereg klawiszy, niektórych może kusić uczynienie typu <code>Fortepian</code> podtypem typu <code>Array</code>, ale fortepian <em>nie jest</em> rodzajem tablicy i jego implementowanie w ten sposób na pewno spowoduje powstanie wielu nonsensów. Fortepian ma też pedały. Można spytać dlaczego element <code>piano[0]</code> reprezentuje pierwszy klawisz, a nie pedał? W tej sytuacji, jako że każdy fortepian <em>ma</em> klawisze, o wiele lepiej byłoby utworzyć obiekt mający własności <code>klawisze</code> i <code>pedaly</code> zawierające tablice.</p>
  <p>Każdy podtyp może być nadtypem innego podtypu. Niektóre problemy nawet najlepiej się rozwiązuje poprzez budowę skomplikowanych drzew rodzinnych typów. Należy tylko uważać, żeby z tym nie przesadzić. Nadużywanie dziedziczenia jest prostą drogą do zamienienia programu w jeden wielki bałagan.</p>
</div>
<hr>
<div class="block">
  <p>Sposób działania słowa kluczowego <code>new</code> i własności <code>prototype</code> konstruktorów narzucają określony sposób używania obiektów. W przypadku prostych obiektów, jak stworzenia w terrarium jest to wystarczające. Jeśli jednak chcemy w programie intensywnie wykorzystywać dziedziczenie, taki sposób obsługi obiektów szybko stanie się niezgrabny. Można sobie ułatwić pracę pisząc funkcje do wykonywania niektórych często wykonywanych zadań. Na przykład wielu programistów definiuje obiektom metody <code>inherit</code> i <code>method</code>.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">inherit</span> = <span class="keyword">function</span>(<span class="variabledef">baseConstructor</span>) {
    <span class="localvariable">this</span>.<span class="property">prototype</span> = <span class="variable">clone</span>(<span class="localvariable">baseConstructor</span>.<span class="property">prototype</span>);
    <span class="localvariable">this</span>.<span class="property">prototype</span>.<span class="property">constructor</span> = <span class="localvariable">this</span>;
};
    <span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">method</span> = <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">func</span>) {
    <span class="localvariable">this</span>.<span class="property">prototype</span>[<span class="localvariable">name</span>] = <span class="localvariable">func</span>;
};

    <span class="keyword">function</span> <span class="variable">StrangeArray</span>(){}
    <span class="variable">StrangeArray</span>.<span class="property">inherit</span>(<span class="variable">Array</span>);
    <span class="variable">StrangeArray</span>.<span class="property">method</span>(<span class="string">"push"</span>, <span class="keyword">function</span>(<span class="variabledef">value</span>) {
    <span class="variable">Array</span>.<span class="property">prototype</span>.<span class="property">push</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">value</span>);
    <span class="variable">Array</span>.<span class="property">prototype</span>.<span class="property">push</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">value</span>);
});

    <span class="keyword">var</span> <span class="variable">strange</span> = <span class="keyword">new</span> <span class="variable">StrangeArray</span>();
    <span class="variable">strange</span>.<span class="property">push</span>(<span class="atom">4</span>);
    <span class="variable">show</span>(<span class="variable">strange</span>);</pre>
  <p>Jeśli poszukasz w internecie informacji na tematy „JavaScript” i dziedziczenie (ang. inheritance), to znajdziesz wiele różnych zdań na ten temat, z których część jest o wiele bardziej skomplikowana i sprytna od przedstawionego przeze mnie.</p>
  <p>Zwróć uwagę na sposób, w jaki napisana tu metoda <code>push</code> wykorzystuje metodę <code>push</code> z prototypu swojego typu nadrzędnego. Jest to często spotykany sposób działania, jeśli chodzi o dziedziczenie — metoda w podtypie wewnętrznie używa metody nadtypu, ale jakoś go rozszerza.</p>
</div>
<hr>
<div class="block">
  <p>Największym problemem z tym prostym podejściem jest dualizm między konstruktorami i prototypami. Konstruktory grają centralną rolę, ponieważ od nich typ obiektowy wywodzi swoją nazwę, a gdy potrzebny jest prototyp, trzeba pobrać własność <code>prototype</code> konstruktora.</p>
  <p>To nie tylko wymaga <em>dużo</em> pisania (słowo <code>prototype</code> składa się z 9 liter), ale i jest mylące. We wcześniejszym przykładzie musieliśmy napisać pusty i bezużyteczny konstruktor dla typu <code>StrangeArray</code>. Sam nie raz omyłkowo dodałem metody do konstruktora zamiast jego prototypu albo próbowałem wywołać <code>Array.slice</code>, gdy w rzeczywistości chciałem <code>Array.prototype.slice</code>. Moim zdaniem prototyp jest najważniejszym aspektem typu obiektowego, a konstruktor jest tylko rozszerzeniem, specjalną metodą.</p>
</div>
<hr>
<div class="block">
  <p>Dodając kilka prostych metod pomocniczych do prototypu <code>Object.prototype</code> można utworzyć alternatywne podejście do obiektów i dziedziczenia. W podejściu tym typ jest reprezentowany przez swój prototyp i do przechowywania prototypów używa się zmiennych o nazwach pisanych wielkimi literami. Gdy trzeba coś „skonstruować”, należy użyć metody o nazwie <code>construct</code>. Dodamy metodę o nazwie <code>create</code> do prototypu <code>Object</code>, która będzie używana w miejsce słowa kluczowego <code>new</code>. Metoda ta będzie klonować obiekt i wywoływać jego metodę <code>construct</code>, jeśli taka istnieje, przekazując jej argumenty, które zostały do niej (<code>create</code>) przekazane.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">create</span> = <span class="keyword">function</span>() {
    <span class="keyword">var</span> <span class="variabledef">object</span> = <span class="variable">clone</span>(<span class="localvariable">this</span>);
    <span class="keyword">if</span> (typeof <span class="localvariable">object</span>.<span class="property">construct</span> == <span class="string">"function"</span>)
    <span class="localvariable">object</span>.<span class="property">construct</span>.<span class="property">apply</span>(<span class="localvariable">object</span>, <span class="localvariable">arguments</span>);
    <span class="keyword">return</span> <span class="localvariable">object</span>;
};</pre>
  <p>Dziedziczenie można zrealizować poprzez sklonowanie obiektu prototypowego i dodanie lub zmodyfikowanie własności. Do tego również napiszemy metodę pomocniczą, o nazwie <code>extend</code>, która będzie klonować obiekt, do którego zostanie zastosowana i dodawać do klonu własności obiektu, który otrzymała w argumencie.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">extend</span> = <span class="keyword">function</span>(<span class="variabledef">properties</span>) {
    <span class="keyword">var</span> <span class="variabledef">result</span> = <span class="variable">clone</span>(<span class="localvariable">this</span>);
    <span class="variable">forEachIn</span>(<span class="localvariable">properties</span>, <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">value</span>) {
    <span class="localvariable">result</span>[<span class="localvariable">name</span>] = <span class="localvariable">value</span>;
  });
    <span class="keyword">return</span> <span class="localvariable">result</span>;
};</pre>
  <p>W przypadkach gdy kombinowanie z prototypem <code>Object</code> nie jest bezpieczne zamiast metod można utworzyć zwykłe funkcje.</p>
</div>
<hr>
<div class="block">
  <p>Na przykład, jeśli jesteś dość stary, to możliwe, że kiedyś grałeś w grę typu „tekstowa przygoda”, w której chodzi się po świecie używając specjalnych poleceń i otrzymuje się opisy znajdujących się w otoczeniu rzeczy oraz wykonywanych działań. Kiedyś to były gry!</p>
  <p>Poniżej znajduje się przykładowy prototyp przedmiotu w takiej.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">Item</span> = {
    <span class="property">construct</span>: <span class="keyword">function</span>(<span class="variabledef">name</span>) {
    <span class="localvariable">this</span>.<span class="property">name</span> = <span class="localvariable">name</span>;
  },
    <span class="property">inspect</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">"To jest "</span>, <span class="localvariable">this</span>.<span class="property">name</span>, <span class="string">"."</span>);
  },
    <span class="property">kick</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">"klunk!"</span>);
  },
    <span class="property">take</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">"Nie możesz podnieść "</span>, <span class="localvariable">this</span>.<span class="property">name</span>, <span class="string">"."</span>);
  }
};

    <span class="keyword">var</span> <span class="variable">lantern</span> = <span class="variable">Item</span>.<span class="property">create</span>(<span class="string">"brązowa latarnia"</span>);
    <span class="variable">lantern</span>.<span class="property">kick</span>();</pre>
  <p>A oto sposób dziedziczenia po nim…</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">DetailedItem</span> = <span class="variable">Item</span>.<span class="property">extend</span>({
    <span class="property">construct</span>: <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">details</span>) {
    <span class="variable">Item</span>.<span class="property">construct</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">name</span>);
    <span class="localvariable">this</span>.<span class="property">details</span> = <span class="localvariable">details</span>;
  },
    <span class="property">inspect</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="string">"Widzisz "</span>, <span class="localvariable">this</span>.<span class="property">name</span>, <span class="string">", "</span>, <span class="localvariable">this</span>.<span class="property">details</span>, <span class="string">"."</span>);
  }
});

    <span class="keyword">var</span> <span class="variable">giantSloth</span> = <span class="variable">DetailedItem</span>.<span class="property">create</span>(
    <span class="string">"wielkiego leniwca"</span>,
    <span class="string">"wisi sobie na drzewie i żuje liście"</span>);
    <span class="variable">giantSloth</span>.<span class="property">inspect</span>();</pre>
  <p>Pozbycie się obowiązkowej części <code>prototype</code> sprawia, że wywołania typu <code>Item.construct</code> z konstruktora <code>DetailedItem</code> są nieco prostsze. Zwróć uwagę, że <code>this.name = name</code> w <code>DetailedItem.construct</code> byłoby złym pomysłem. Byłoby to zduplikowanie wiersza. Oczywiście powielenie jednego wiersza jest lepsze niż wywołanie funkcji <code>Item.construct</code>, ale jeśli później zechcemy cos dodać do tego konstruktora, to będziemy musieli zrobić to w dwóch miejscach.</p>
</div>
<hr>
<div class="block">
  <p>W większości przypadków konstruktor podtypu powinien zaczynać działanie od wywołania konstruktora nadtypu. Dzięki temu pracę rozpoczyna od poprawnego obiektu nadtypu, który następnie rozszerza. W tym podejściu do prototypów typy nie wymagające konstruktora mogą go opuścić. Odziedziczą go automatycznie po nadtypie.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">SmallItem</span> = <span class="variable">Item</span>.<span class="property">extend</span>({
    <span class="property">kick</span>: <span class="keyword">function</span>() {
    <span class="variable">print</span>(<span class="localvariable">this</span>.<span class="property">name</span>, <span class="string">" fruwa po pokoju."</span>);
  },
    <span class="property">take</span>: <span class="keyword">function</span>() {
    <span class="comment">// (wyobraź sobie tutaj kod wkładający przedmiot do Twojej kieszeni)</span>
    <span class="variable">print</span>(<span class="string">"Bierzesz "</span>, <span class="localvariable">this</span>.<span class="property">name</span>, <span class="string">"."</span>);
  }
});

    <span class="keyword">var</span> <span class="variable">pencil</span> = <span class="variable">SmallItem</span>.<span class="property">create</span>(<span class="string">"czerwony ołówek"</span>);
    <span class="variable">pencil</span>.<span class="property">take</span>();</pre>
  <p>Mimo że typ <code>SmallItem</code> nie definiuje własnego konstruktora, można go tworzyć przy użyciu argumentu <code>name</code>, ponieważ dziedziczył konstruktor po prototypie <code>Item</code>.</p>
</div>
<hr>
<div class="block">
  <p>W języku JavaScript znajduje się operator o nazwie <code>instanceof</code>, za pomocą którego można sprawdzić czy obiekt jest utworzony na bazie określonego prototypu. Po lewej stronie podaje się obiekt, a po prawej konstruktor. Zwracana jest wartość logiczna: <code>true</code> jeśli własność <code>prototype</code>konstruktora jest bezpośrednim lub pośrednim prototypem obiektu lub <code>false</code> w przeciwnym przypadku.</p>
  <p>Jeśli nie są używane zwykłe konstruktory, używanie tego operatora jest trochę nieporęczne — jego drugim argumentem powinna być funkcja konstrukcyjna, a my mamy tylko prototypy. Problem ten można rozwiązać stosując sztuczkę podobną do tej z funkcją <code>clone</code>: Operatorowi <code>instanceof</code> przekazujemy „fałszywy” konstruktor.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="variable">Object</span>.<span class="property">prototype</span>.<span class="property">hasPrototype</span> = <span class="keyword">function</span>(<span class="variabledef">prototype</span>) {
    <span class="keyword">function</span> <span class="variabledef">DummyConstructor</span>() {}
    <span class="localvariable">DummyConstructor</span>.<span class="property">prototype</span> = <span class="localvariable">prototype</span>;
    <span class="keyword">return</span> <span class="localvariable">this</span> instanceof <span class="localvariable">DummyConstructor</span>;
};

    <span class="variable">show</span>(<span class="variable">pencil</span>.<span class="property">hasPrototype</span>(<span class="variable">Item</span>));
    <span class="variable">show</span>(<span class="variable">pencil</span>.<span class="property">hasPrototype</span>(<span class="variable">DetailedItem</span>));</pre>
</div>
<hr>
<div class="block">
  <p>Następnie chcemy utworzyć mały przedmiot, który ma szczegółowy opis. Wydaje się że przedmiot ten powinien dziedziczyć zarówno po <code>DetailedItem</code> jak i <code>SmallItem</code>. W JavaScripcie obiekt nie może mieć kilku prototypów, a nawet gdyby mógł, problem i tak nie byłby łatwy do rozwiązania. Na przykład, gdyby <code>SmallItem</code> z jakiegoś powodu zawierał definicję metody <code>inspect</code>, której metody <code>inspect</code> używałby nowy prototyp?</p>
  <p>Derywacja typu obiektu z więcej niż jednego typu nadrzędnego nazywa się wielodziedziczeniem. W niektórych językach jest to całkowicie zabronione, a w innych opracowano skomplikowane zasady, aby to działało i było praktyczne. W języku JavaScript można zaimplementować porządny schemat wielodziedziczenia. Oczywiście, jak to zwykle bywa, można to zrobić na kilka sposobów. Jest to jednak zbyt skomplikowane, aby to tutaj omawiać. Dlatego przedstawiam tylko proste rozwiązanie, które powinno wystarczyć w większości przypadków.</p>
</div>
<hr>
<div class="block">
  <p>Domieszka (ang. mix-in) to specjalny rodzaj prototypu, który można „wmieszać” w inne prototypy. W ten sposób można potraktować prototyp <code>SmallItem</code>. Kopiując jego metody <code>kick</code> i <code>take</code> do innego prototypu dodamy do niego domieszkę.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">function</span> <span class="variable">mixInto</span>(<span class="variabledef">object</span>, <span class="variabledef">mixIn</span>) {
    <span class="variable">forEachIn</span>(<span class="localvariable">mixIn</span>, <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">value</span>) {
    <span class="localvariable">object</span>[<span class="localvariable">name</span>] = <span class="localvariable">value</span>;
  });
};

    <span class="keyword">var</span> <span class="variable">SmallDetailedItem</span> = <span class="variable">clone</span>(<span class="variable">DetailedItem</span>);
    <span class="variable">mixInto</span>(<span class="variable">SmallDetailedItem</span>, <span class="variable">SmallItem</span>);

    <span class="keyword">var</span> <span class="variable">deadMouse</span> = <span class="variable">SmallDetailedItem</span>.<span class="property">create</span>(
    <span class="string">"Mysz Fred"</span>,
    <span class="string">"on jest martwy"</span>);
    <span class="variable">deadMouse</span>.<span class="property">inspect</span>();
    <span class="variable">deadMouse</span>.<span class="property">kick</span>();</pre>
  <p>Pamiętaj, że <code>forEachIn</code> przegląda tylko własności <em>należące</em> do obiektu, a więc skopiuje metody <code>kick</code> i <code>take</code>, ale nie skopiuje konstruktora odziedziczonego przez <code>SmallItem</code> po <code>Item</code>.</p>
</div>
<hr>
<div class="block">
  <p>Mieszanie prototypów staje się o wiele bardziej skomplikowane, gdy domieszka ma konstruktor lub gdy niektóre jej metody kolidują nazwami z metodami prototypu, do którego są dodawane. Czasami da się wykonać „domieszkowanie ręczne”. Powiedzmy, że mamy prototyp <code>Monster</code>, który ma swój własny konstruktor, i chcemy go zmieszać z <code>DetailedItem</code>.</p>
  <pre class="code not-run"><button class="codebutton run" title="Wykonaj ten kod" type="button"></button><button class="codebutton load" type="button" title="Wczytaj ten kod do konsoli"></button><span class="keyword">var</span> <span class="variable">Monster</span> = <span class="variable">Item</span>.<span class="property">extend</span>({
    <span class="property">construct</span>: <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">dangerous</span>) {
    <span class="variable">Item</span>.<span class="property">construct</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">name</span>);
    <span class="localvariable">this</span>.<span class="property">dangerous</span> = <span class="localvariable">dangerous</span>;
  },
    <span class="property">kick</span>: <span class="keyword">function</span>() {
    <span class="keyword">if</span> (<span class="localvariable">this</span>.<span class="property">dangerous</span>)
    <span class="variable">print</span>(<span class="localvariable">this</span>.<span class="property">name</span>, <span class="string">" odgryza Ci głowę."</span>);
    <span class="keyword">else</span>
    <span class="variable">print</span>(<span class="localvariable">this</span>.<span class="property">name</span>, <span class="string">" ucieka, szlochając."</span>);
  }
});

    <span class="keyword">var</span> <span class="variable">DetailedMonster</span> = <span class="variable">DetailedItem</span>.<span class="property">extend</span>({
    <span class="property">construct</span>: <span class="keyword">function</span>(<span class="variabledef">name</span>, <span class="variabledef">description</span>, <span class="variabledef">dangerous</span>) {
    <span class="variable">DetailedItem</span>.<span class="property">construct</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">name</span>, <span class="localvariable">description</span>);
    <span class="variable">Monster</span>.<span class="property">construct</span>.<span class="property">call</span>(<span class="localvariable">this</span>, <span class="localvariable">name</span>, <span class="localvariable">dangerous</span>);
  },
    <span class="property">kick</span>: <span class="variable">Monster</span>.<span class="property">kick</span>
});

    <span class="keyword">var</span> <span class="variable">giantSloth</span> = <span class="variable">DetailedMonster</span>.<span class="property">create</span>(

    <span class="string">"Wielki leniwiec"</span>,
    <span class="string">"wisi sobie na drzewie i żuje liście"</span>,
    <span class="atom">true</span>);
    <span class="variable">giantSloth</span>.<span class="property">kick</span>();</pre>
  <p>Zauważ jednak, że konstruktor <code>Item</code> przy tworzeniu <code>DetailedMonster</code> jest wywoływany dwukrotnie ― raz poprzez konstruktor <code>DetailedItem</code>, a drugi raz poprzez konstruktor <code>Monster</code>. W tym przypadku nie powoduje to wielkich szkód, ale w innych może być poważnym problemem.</p>
</div>
<hr>
<div class="block">
  <p>Mimo tych komplikacji nie zniechęcaj się do dziedziczenia. Wielodziedziczenie, mimo że czasami bardzo przydatne, w większości przypadków można sobie darować. Dlatego właśnie w takich językach jak Java jest ono zabronione. A jeśli kiedyś będziesz go naprawdę potrzebować, możesz poszukać informacji w internecie, zrobić rozeznanie i znaleźć rozwiązanie idealne dla siebie.</p>
  <p>Tak mi teraz przyszło do głowy, że JavaScript byłby doskonałym językiem do napisania tekstowej gry przygodowej. Bardzo w tym pomaga możliwość zmieniania zachowań obiektów, którą mamy dzięki prototypowemu dziedziczeniu. Jeśli masz obiekt <code>hedgehog</code>, który ma niezwykłą zdolność toczenia się, gdy zostanie kopnięty, możesz tylko zmienić jego metodę <code>kick</code>.</p>
  <p>Niestety tekstowe przygodówki podzieliły losy płyt winylowych i mimo że kiedyś były bardzo popularne, dziś gra w nie tylko garstka <a href="http://groups.google.com/group/rec.arts.int-fiction/topics">zapaleńców</a>.</p>
</div>
<h3>Przypisy</h3>
<ol>
  <li id="footnote1">Takie typy w innych językach zazwyczaj nazywają się klasami.</li>
  <li id="footnote2">Dla uproszczenia stworzenia w naszym terrarium rozmnażają się bezpłciowo, same z siebie.</li>
  <li id="footnote3">Lenistwo w przypadku programistów niekoniecznie oznacza coś złego. Osoby, które lubią wielokrotnie powtarzać te same czynności są dobrymi robotnikami przy taśmach montażowych i słabymi programistami.</li>
</ol>
